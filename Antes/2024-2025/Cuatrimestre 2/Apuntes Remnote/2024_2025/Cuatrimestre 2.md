- Exámenes y prácticas
    - Exámenes Y Prácticas:
        - # Multimedia:
            - ## Practica 1: Entrega Práctica 1 - 10 de Marzo (P1: 10%) (Video P1: 20%)
            - ## Práctica 2: Entrega práctica 2 - 10 de Abril (P2: 10%) (Video P2: 20%)
            - ## Práctica 3: Entrega Práctica 3 - 8 de Mayo (P3: 10%) (Video P3: 30%)
            - 
        - 
        - # MOEG:
            1. ## Prueba Temas 1 y 2 (30%) (min:5/10) -  08/04/2025 #[[Semana 7/8]] 
            2. ## Prueba Temas 3, 4 y 5 (30%)  (min:5/10) - Convocatoria Ordinaria
            - ## Prácticas:
                - ### Resolución de problemas y casos prácticos. Nota media de 5 Problemas y casos prácticos de los Temas 1, 2, 3, 4 y 5. (20%)
                1. ### Realización de prácticas con el ordenador.  Nota media de 5- Práctica 1: Introducción al sóftware de optimización - Práctica 2: sóftware de optimización lineal.- Práctica 3: sóftware de optimización no lineal- Practica 1: Semana 4- Práctica 2: Semana 8- Práctica 3: Semana 12 (20%)
        - 
        - # DAA:
            1. ## Examen 1:Prueba resolución de problemas(10%) (min:2/10) -  #[[Semana 7/8]] 
            2. ## Prueba resolución de problemas(60%) (min:5/10) - Convocatoria Ordinaria
            - ## Ejercicios(30%)(min:4/10):
                - ### Introducción:
                - ### Grafos:
                - ### Voraces:
        - 
        - # Evolución y adaptación del software:
            - ## Exámenes:
                1. ### Examen de teoría(40%) (min: media de 4/10 con examen problemas) - Ordinaria
                2. ### Examen de problemas(20%) (min: media de 4/10 con examen teoría) - Ordinaria
            - ## Prácticas:
                1. ### Práctica obligatoria entrega final(20%) (min: media de 4/10 con control de versiones) - Todo el curso
                2. ### Sesiones prácticas seguimiento de control de versiones(20%) (min: media de 4/10 con práctica) - Todo el curso
        - # Metodología de la programación:
            - ## Exámenes:
                1. ### Parcial T3 - T6: 21 de Marzo (25%)(min:5/10)
                2. ### Parcial T1,T2 y T7: 23 de Mayo (25%)(min:5/10)
                3. ### Autoevaluaciones T1 - T7: 9 de Mayo (10%)(min:0/10)
            - ## Prácticas:
                1. ### Fase Análisis: 20 de Febrero (10%) (min:5/10)
                2. ### Fase Diseño: 6 de Marzo(10%) (min:5/10)
                3. ### Fase Codificación: 27 Marzo(10%) (min:5/10)
                4. ### Fase Pruebas: 10 de Abril (10%) (min:5/10)
    - # Multimedia:
        - ## Practica 1: Entrega Práctica 1 - 10 de Marzo (P1: 10%) (Video P1: 20%)
        - ## Práctica 2: Entrega práctica 2 - 10 de Abril (P2: 10%) (Video P2: 20%)
        - ## Práctica 3: Entrega Práctica 3 - 8 de Mayo (P3: 10%) (Video P3: 30%)
        - 
    - # MOEG:
        1. ## Prueba Temas 1 y 2 (30%) (min:5/10) -  08/04/2025 #[[Semana 7/8]] 
        2. ## Prueba Temas 3, 4 y 5 (30%)  (min:5/10) - Convocatoria Ordinaria
        3. ## Prácticas:
            - ### Resolución de problemas y casos prácticos. Nota media de 5 Problemas y casos prácticos de los Temas 1, 2, 3, 4 y 5. (20%)
            1. ### Realización de prácticas con el ordenador.  Nota media de 5- Práctica 1: Introducción al sóftware de optimización - Práctica 2: sóftware de optimización lineal.- Práctica 3: sóftware de optimización no lineal- Practica 1: Semana 4- Práctica 2: Semana 8- Práctica 3: Semana 12 (20%)
    - # DAA:
        1. ## Examen 1:Prueba resolución de problemas(10%) (min:2/10) -  #[[Semana 7/8]] 
        2. ## Prueba resolución de problemas(60%) (min:5/10) - Convocatoria Ordinaria
        3. ## Ejercicios(30%)(min:4/10):
            - ### Introducción:
            - ### Grafos:
            - ### Voraces:
    - # Evolución y Adaptación del Software:
        - ## Exámenes:
            1. ### Examen de teoría(40%) (min: media de 4/10 con examen problemas) - Ordinaria
            2. ### Examen de problemas(20%) (min: media de 4/10 con examen teoría) - Ordinaria
        - ## Prácticas:
            1. ### Práctica obligatoria entrega final(20%) (min: media de 4/10 con control de versiones) - Todo el curso
            2. ### Sesiones prácticas seguimiento de control de versiones(20%) (min: media de 4/10 con práctica) - Todo el curso
    - # Metodología de la Programación:
        - ## Exámenes:
            1. ### Parcial T3 - T6: 21 de Marzo (25%)(min:5/10)
            2. ### Parcial T1,T2 y T7: 23 de Mayo (25%)(min:5/10)
            3. ### Autoevaluaciones T1 - T7: 9 de Mayo (10%)(min:0/10)
        - ## Prácticas:
            1. ### Fase Análisis: 20 de Febrero (10%) (min:5/10)
            2. ### Fase Diseño: 6 de Marzo(10%) (min:5/10)
            3. ### Fase Codificación: 27 Marzo(10%) (min:5/10)
            4. ### Fase Pruebas: 10 de Abril (10%) (min:5/10)
- # Multimedia 
    - Índice Multimedia
        - #  _**Fechas relevantes:**_  
            - ## Prácticas(min:5/10) : 
                1. Entrega Práctica 1 - 10 de Marzo (P1: 10%) (Video P1: 20%)
                2. Entrega práctica 2 - 10 de Abril (P2: 10%) (Video P2: 20%)
                3. Entrega Práctica 3 - 8 de Mayo (P3: 10%) (Video P3: 30%)
        - 
        - #  _**Profesorado:**_  
            - ### Liliana Patricia Santacruz Valencia
                - **Despacho: **2016, Amplificación del Rectorado.
                - **Email**: liliana.santacruz@urjc.es
                - **Tutorías**:  Lunes [13:00/15:00] y  Miércoles [17:00/19:00] o solicitar por el bloque de correo del Aula virtual
        - 
        - #  _**Índice:**_  
            - # Bloque 1: Tecnologías Multimedia
                1. Fundamentos y Caracterización // Creación de un juego con HTML5
                    1. Mundo Básico
                    2. Simulación
                    3. Integración
                2. Fundamentos de Realidad Aumentada// Objetos RA

            - # Bloque 2: Accesibilidad
                - 3. Contenido Web Accesible
        - 
    - Tema 1.- Creación de un juego con HTML5
        1. #  _**Canvas**_  
            - El elemento lienzo proporciona scripts con un lienzo de mapa de bits que depende de la resolución, puede servir para renderizar sobre la marcha.
            - Permite dibujar figuras y texto, optimizado para uso rápido.
            - .
                ```
                <canvas width="600" height="400" id="testcanvas" style="border: 1px solid black;"> 
                ```
                - Atributos obligatorios para el Canvas.
            - 
            - Ejemplo:
                - .
                    ```
                    // Rectángulos rellenos
// Dibutar un cuadrado sólido con ancho y alto de 100 pixels en (200,10)
context. fillRect (200,10,100,100):
// Dibujar un cuadrado sólido con ancho de 90 y alto 30 pixels en (50,70)
context. fillRect (50,70,90,30);
// Contornos rectangulares
// Dibujar un contorno rectangular de ancho y alto de 50 pixels en (110,10)
context. strokeRect (110,10,50,50);
// Dibujar un contorno rectangular de ancho y alto de 50 pixels en (30,10)
context. strokeRect (30,10,50,50):

                    ```
            - Ejemplo para inicializarlo en JS y poder pintar de forma programática:
                - .
                    ```
                    <canvas id="main-canvas" width="900" height="900"> </canvas> 
                    ```
                - .
                    ```
                    const mainCanvas = document.getElementById("main-canvas");
const context = mainCanvas.getContext("2d"); 

let initialX;
let initialY;
                    ```
            - 
- # MOEG 
    - Examen 1
        - 
        - MOEG son 4 ejercicios a realizar, 2 de programación lineal, uno de modelizar y el otro de resolver una modelización, otros dos que son de programación no lineal, uno será como el ejemplo de la Coca-Cola o un terreno, y el otro ejercicio será de cálculo de heissiana por ahí seguro. Según nos comentó el profe sustituto.
        - 
    - Índice MOEG
        - #  _**Fechas relevantes:**_  
            - ## Exámenes:
                1. Prueba Temas 1 y 2 (30%) (min:5/10) -  08/04/2025 #[[Semana 7/8]] 
                2. Prueba Temas 3, 4 y 5 (30%)  (min:5/10) - Convocatoria Ordinaria
            - ## Prácticas:
                - Resolución de problemas y casos prácticos. Nota media de 5 Problemas y casos prácticos de los Temas 1, 2, 3, 4 y 5. (20%)
                1. Realización de prácticas con el ordenador.  Nota media de 5- Práctica 1: Introducción al sóftware de optimización - Práctica 2: sóftware de optimización lineal.- Práctica 3: sóftware de optimización no lineal- Practica 1: Semana 4- Práctica 2: Semana 8- Práctica 3: Semana 12 (20%)
            -  ***TODO REVALUABLE*** ** ** 
        - #  _**Profesorado:**_ 
            - ### Prof. César Beltrán  
                - **Despacho: **037. Departamental II. Campus de Móstoles.  
                - **Contacto**:  escribiendo al **Correo** () cesar.beltran@urjc.es.
            - ### Prof. Andrés Redchuk  
                - **Despacho: **2022.  Edificio Ampliación de Rectorado. Campus de Móstoles.  
                - **Contacto**:
                    1. Puedes contactar conmigo a través de la herramienta **Correo** (), situada en la parte superior derecha de la pantalla o del **Foro general.**

                    2. Los mensajes y correos electrónicos los respondo siempre los lunes, miércoles y viernes por la tarde.
                    3. En caso de que necesites contactar conmigo de manera urgente puedes localizarme en el correo andres.redchuk@urjc.es.
        - 
        - #  _**Índice:**_ 
            - [Tema 1: Introducción.](Cuatrimestre%202/MOEG/T1.-Introducci%C3%B3n.md) 
            - [Tema 2: Programación lineal.](Cuatrimestre%202/MOEG/T2.-Programaci%C3%B3n%20Lineal.md) 
            - [Tema 3: Programación no lineal sin restricciones.](Cuatrimestre%202/MOEG/T3.-Programaci%C3%B3n%20no%20lineal%20sin%20restricciones.md) 
        - 
    - T1.-Introducción
    - T2.-Programación Lineal
        - 
        - ## 2.1. Introducción 
            - **Optimizar:** Dado un conjunto de dos o más opciones, elegir la mejor.
            - La posibilidad de optimizar es ubicua:
                - **-** *Número de cajeros/as: * +Cajeros = +Satisfacción clientes y +Coste al supermercado.
                - **-** *Precio de producto: * +Precio = +Ganancias por producto y -Ventas.
                - **-** *ETC...* 
            - A menudo se usa "Programación lineal" como sinónimo de "Optimización Lineal", ya que se programan y planifican operaciones.
            - Estructura del capítulo:
                - Modelos de PL.
                - Introducción a técnicas de resolución.
                - Postoptimización.
        - ## 2.2. Modelos de la programación lineal
            - Apartados:
                - Modelos de asignación de recursos.
                - Modelos de mezclas.
                - Modelos de planificación de operaciones.
                - Modelos de gestión de personal.
                - Modelos temporales (Multiperiodo).
            - ### 2.2.1. Modelos de asignación de recursos
                - **Ejemplo 1 (Asignación de horas de estudio):**
                    -  _Datos_ :
                        - Juan, estudia ING, quiere maximizar resultados académicos.
                        - Numero horas disponibles para estudiar: 30h.
                        - Estimación incremento de nota por cada hora de estudio
                            - --------------------- Portal ---------------------Investigación Operativa (IO)
                                - Investigación Operativa (IO) #[[Investigación Operativa (IO)]] 
                                    - [2%](Cuatrimestre%202/MOEG/T2.-Programaci%C3%B3n%20Lineal/2.2.%20Modelos%20de%20la%20programaci%C3%B3n%20lineal/2.2.1.%20Modelos%20de%20asignaci%C3%B3n%20de%20recursos/Ejemplo%201%20(Asignaci%C3%B3n%20de%20horas%20de%20estudio)_/Datos_/Estimaci%C3%B3n%20incremento%20de%20nota%20por%20cada%20hora%20de%20estudio/Investigaci%C3%B3n%20Operativa%20(IO)/Investigaci%C3%B3n%20Operativa%20(IO)/2%25.md);-2%
                                - Ingeniería Económica (IE) #[[Investigación Operativa (IO)]] 
                                    - [2%](Cuatrimestre%202/MOEG/T2.-Programaci%C3%B3n%20Lineal/2.2.%20Modelos%20de%20la%20programaci%C3%B3n%20lineal/2.2.1.%20Modelos%20de%20asignaci%C3%B3n%20de%20recursos/Ejemplo%201%20(Asignaci%C3%B3n%20de%20horas%20de%20estudio)_/Datos_/Estimaci%C3%B3n%20incremento%20de%20nota%20por%20cada%20hora%20de%20estudio/Investigaci%C3%B3n%20Operativa%20(IO)/Investigaci%C3%B3n%20Operativa%20(IO)/2%25.md);-3%
                                - Estadística (ES)  #[[Investigación Operativa (IO)]] 
                                    - [2%](Cuatrimestre%202/MOEG/T2.-Programaci%C3%B3n%20Lineal/2.2.%20Modelos%20de%20la%20programaci%C3%B3n%20lineal/2.2.1.%20Modelos%20de%20asignaci%C3%B3n%20de%20recursos/Ejemplo%201%20(Asignaci%C3%B3n%20de%20horas%20de%20estudio)_/Datos_/Estimaci%C3%B3n%20incremento%20de%20nota%20por%20cada%20hora%20de%20estudio/Investigaci%C3%B3n%20Operativa%20(IO)/Investigaci%C3%B3n%20Operativa%20(IO)/2%25.md);-1%
                                - Programación (PR)  #[[Investigación Operativa (IO)]] 
                                    - [2%](Cuatrimestre%202/MOEG/T2.-Programaci%C3%B3n%20Lineal/2.2.%20Modelos%20de%20la%20programaci%C3%B3n%20lineal/2.2.1.%20Modelos%20de%20asignaci%C3%B3n%20de%20recursos/Ejemplo%201%20(Asignaci%C3%B3n%20de%20horas%20de%20estudio)_/Datos_/Estimaci%C3%B3n%20incremento%20de%20nota%20por%20cada%20hora%20de%20estudio/Investigaci%C3%B3n%20Operativa%20(IO)/Investigaci%C3%B3n%20Operativa%20(IO)/2%25.md);-5%
                        - Juan quiere:
                            - Que el Nº de horas que le dedica a IO sea igual o superior al resto.
                            - Máximo de 10 horas de estudio por asignatura.
                    -  _Objetivo_ : Formula como un PL
                    -  _Operaciones_ :
                        - Variables de decisión:
                            - $x_{j} := \text{Horas dedicadas a la asignatura j,}$
                                - 

                                  $$\begin{align*}j \in \{\text{IO}, \text{IE}, \text{ES}, \text{PR}\}\end{align*}$$

                                  
                        - La formulación como PL es:
                            - $\triangleright \text{ Maximizar el incremento acumulado de las notas de Juan (en\%):}$
                                - 

                                  $$\begin{align*} z(x) = 2 x_{IO} + 3 x_{IE} + 1 x_{ES} + 5 x_{PR}\end{align*}$$

                                  
                            - $\triangleright \text{ Sujeto a las siguientes restricciones:}\\$
                                - 

                                  $$\begin{align*}
x_{IO} + x_{IE} + x_{ES} + x_{PR} &= 30 \quad \text{(asignación de las horas)} \\
x_{IO} &\geq x_{IE} \quad \text{(IO es la que más tiene)} \\
x_{IO} &\geq x_{ES} \\
x_{IO} &\geq x_{PR} \\
x_{IO} &\leq 10 \quad \text{(máximo 10 h)} \\
x_{IE} &\leq 10 \\
x_{ES} &\leq 10 \\
x_{PR} &\leq 10 \\
x_{IO} &\geq 0 \quad \text{(mínimo 0 h)} \\
x_{IE} &\geq 0 \\
x_{ES} &\geq 0 \\
x_{PR} &\geq 0
\end{align*}$$

                                  
                    -  _Solución_ :
                        - De forma compacta podemos escribir:
                            - 

                              $$\begin{align*}
\text{max} \quad z =\; & 2 x_{IO} + 3 x_{IE} + 1 x_{ES} + 5 x_{PR} & \text{(incremento total)} \\
\text{s.a.} \quad
& x_{IO} + x_{IE} + x_{ES} + x_{PR} = 30 & \text{(asignación)} \\
& x_{IO} \geq x_j, \quad j \in \{IE, ES, PR\} & \text{(IO es la que más tiene)} \\
& x_j \leq 10, \quad j \in \{IO, IE, ES, PR\} & \text{(máximo 10 h)} \\
& x_j \geq 0, \quad j \in \{IO, IE, ES, PR\} & \text{(mínimo 0 h)}
\end{align*}$$

                              
                        - Más adelante resolveremos este tipo de problemas.
                        - De momento nos conformamos con saber que una solución óptima podría ser:
                            - 

                              $$x^*_{IO} = 10,
x^*_{IE} = 10,
x^*_{ES} = 0,
x^*_{PR} = 10$$

                              
                        - Para indicar valores óptimos usamos los símbolos x* y z*
                - **General:** 
    - T3.-Programación no lineal sin restricciones
- # Diseño y Análisis de Algoritmos
    - Indice DAA
        - #  _**Fechas relevantes:**_  
        - ## Exámenes: 
            1. Prueba resolución de problemas(10%) (min:2/10) -  #[[Semana 7/8]] 
            2. Prueba resolución de problemas(60%) (min:5/10) - Convocatoria Ordinaria
        - ## Prácticas:
            1. Varias entregas a lo largo del cuatrimestre (30%) (min:4/10)
        - 
        - #  _**Profesorado:**_  
        - ### Abraham Duarte Muñoz
        - **Despacho: **109 Departamental II
        - **Email**: abraham.duarte@urjc.es
        - **Tutorías**: solicitar por el bloque de correo
        - ### Jesús Sánchez-Oro Calvo
        - **Despacho: **115 Departamental II
        - **Email**: jesus.sanchezoro@urjc.es
        - **Tutorías**: solicitar por el bloque de correo
        - ### Alejandra Casado Ceballos
            - **Despacho: **117 Departamental II
            - **Email**: alejandra.casado@urjc.es
            - **Tutorías**: solicitar por el bloque de correo
            - 
        - #  _**Índice:**_  
        - ## Modulo I
        - [Tema 0: Introducción a Python.](Cuatrimestre%202/Dise%C3%B1o%20y%20An%C3%A1lisis%20de%20Algoritmos/T0.-Introducci%C3%B3n%20a%20Python.md) 
        - [Tema 1: Planteamiento general](Cuatrimestre%202/Dise%C3%B1o%20y%20An%C3%A1lisis%20de%20Algoritmos/T1.-Planteamiento%20General.md) 
            - [Tema 1.1: Eficiencia algorítmica ](Cuatrimestre%202/Dise%C3%B1o%20y%20An%C3%A1lisis%20de%20Algoritmos/T1.1-Eficiencia%20Algor%C3%ADtmica.md) 
        - [Tema 2: Algoritmos en grafos.](Cuatrimestre%202/Dise%C3%B1o%20y%20An%C3%A1lisis%20de%20Algoritmos/T2.-Algoritmos%20en%20Grafos.md) 
        - [Tema 3: Algoritmos Voraces.](Cuatrimestre%202/Dise%C3%B1o%20y%20An%C3%A1lisis%20de%20Algoritmos/T3.-Algoritmos%20Voraces.md) 
            - [Tema 3.1: Algoritmos Voraces sobre grafos.](Cuatrimestre%202/Dise%C3%B1o%20y%20An%C3%A1lisis%20de%20Algoritmos/T3.1-Algoritmos%20Voraces%20sobre%20Grafos.md) 
        - --------------------- Portal ---------------------
            - 
        - 
    - T0.-Introducción a Python 
    - T1.-Planteamiento General 
    - T1.1-Eficiencia Algorítmica 
        - 
    - T2.-Algoritmos en Grafos 
        - # Definiciones
            - Se suele definir un grafo G=(V,E) como un conjunto de vertices V y de aristas $E \subseteq V \times V$.
            - Usualmente la complejidad de los algoritmos sobre grafos suele medirse en función del número de vértices |V|=n y el número de aristas |E|=m.
            - Existen dos representaciones típicas de grafos:
                - ### Lista de adyacencia:
                    - Representación compacta para grafos dispersos (pocas aristas)($|E| \ll|V|^2$).
                    - No aseguran un acceso rápido a la hora de comprobar si hay una arista entre 2 vértices dados.
                    - **Implementaciones: **
                        - Lista de listas: Para grafos no muy densos que den listas cortas.
                        - Diccionario de listas: Parecido a lista de listas.
                        - Diccionario de Diccionarios: Si es muy denso o no se sabe, conviene.
                            - Espacio, igual O(V+E).
                            - Agregar vértice -> Aunque quieras verificar si se repite O(1)
                            - Agregar arista -> O(1)
                            - Ver si dos vértices son adyacentes -> O(1)
                            - Obtener los adyacentes de un vértice -> O(V) * [Encontrar la lista en diccionario O(1), copiarla O(V)]*  
                    - **Costos:** 
                        - Espacio: -> O(V+E) * [Generalmente bastante menos espacio]*  
                        - Agregar vértice -> O(1)   *[O(V) Si queremos verificar que no está repetido en la lista]*   *[menos O() que en Matriz Ady.]*  
                        - Agregar arista -> O(V)
                        - Ver si dos vértices son adyacentes -> O(V)
                        - Obtener los adyacentes de un vértice -> O(V)
                - ### Matriz de adyacencia: 
                    - Aseguran un acceso rápido a la hora de comprobar si hay una arista entre dos vértices dados
                    - Se requiere una memoria de $O(V^2)$, y no depende de la densidad del grafo
                    - Para grafos densos $|E| \cong |V|^2$
                    - **Costos:**
                        - Espacio -> O(V^2^)
                        - Agregar vértice -> O(V^2^)
                        - Agregar arista -> 0(1)  *[Mucho menos O() que Lista Ady.]*  
                        - Ver si dos vértices son adyacentes -> O(1)  *[Mucho menos O() que Lista Ady.]*  
                        - Obtener los adyacentes de un vértice -> O(V)
                        - 
        - # Recorrido en profundidad
            - El depth-first search(dfs) profundiza en el grafo siempre que sea posible
            - Dado un vértice antes de visitar su hermano, visita su hijo (Equivalente a un recorrido preorden).
            - Suele implementarse de forma recursiva
            - Se incluye el conjunto verticesVisitados para evitar ciclos en la búsqueda.
            - ### Pseudocódigo:
                - 
                    - 
                        - DFS Recursividad (rp llama a rp):
                        - ![](https://remnote-user-data.s3.amazonaws.com/pLaez664cP4P-QaWTYKOOqu2wEtoazA3CHxxK0CP_osIS7DbHWFZCeFMrDgR3kyfObSSV89UrkUYpHTNgfzwQezAK5RG-RkJHp7uF18OBxui7mvPRONV26n43P-f2VqE.png)
                        - ![](https://remnote-user-data.s3.amazonaws.com/rOSw7VYZCImAwo7iyUsgFHCJrbubD4WabUzgBmvr3M5sn8EMSakqdCbOuSFQSnYt5U89NVP12TgsfLQx2dT3q4ehAGgn7tBg0Jh7W3Kc_DSGo7cZIK2WtJ4s8hMrnlBO.png)
                    - 
                        - DFS 
                        - Iterativo (con pila)  *[DPila]*  
                        - ![](https://remnote-user-data.s3.amazonaws.com/JOGgmNKPSJ-CxO44H4r8ZB84V7aqdBO6rb2xNVpv5cfqOCW-6XVAViOBiniBkP7aPMWTSUY4dBIaONujiD3QOrtBNS4-LrPC8VS9krV3yWoTUK2o9-Am7U3aTZlb1FE5.png)
                        - 
            - .
                ```
                def dfs_standard(graph, start_node):
    visited = set()
    result = []
    
    def dfs_recursive(node):
        # Marcar como visitado
        visited.add(node)
        # Procesar el nodo ahora
        result.append(node)
        
        # Explorar vecinos
        if node in graph:
            for neighbor in graph[node]:
                if neighbor not in visited:
                    dfs_recursive(neighbor)
        
        # No hay procesamiento aquí
    
    dfs_recursive(start_node)
    return result
                ```
            - Complejidad global del algoritmo es: $O(max(V,E))$. Cada vértice se visita una vez O(V) y el algoritmo examina todas las aristas O(E).
            - El DFS de un grafo conexo G crea un árbol de recubrimiento T:
                - Las aristas de T son un subconjunto de las de G.
                - La raíz de T es el punto de partida de la exploración de G.
            - ![](https://remnote-user-data.s3.amazonaws.com/qSPTv7m_moqheQjXA9ufrRnH3W4SiLw-UH5IVdojWEdPEW1IZht2I0Yn8i7dy1FziDZGpEjMGrpNNTvA_JLpmvWM_Ib8ty240w-9OPklmYPFnjkRrdlH2LcA8MPjAge0.png)->![](https://remnote-user-data.s3.amazonaws.com/eHe2KA7T304d2eaJwcXnPOoQHegM3zRz4GJkzHfAw5s6Y-Y_gbqgLEbJkNRO8_O_0Zi1UClFPcfGd2RjJElT7nujqAqkzLSvzteoRZVP63c5xGve9pL296DZbfiN4qSN.png) 
            - Si el grafo no es conexo se obtiene un grafo por cada componente conexa (bosque).
                -  *Ejemplo de con grafo dirigido(distingue entre adyacentes e incidentes) no conexo:*  
                    - ![](https://remnote-user-data.s3.amazonaws.com/jvNfPVLGxf6F1aTohm_gpoz384XaNkc_8ljVCZ-ut-7ehc-BJWNlxrpKN1CwizwHuW5fPJOwwRr5ol8QVTinsS_2Um-Qy2ncUAMoUEP47ltHwcNi5uZAkuBDOsgoZ0O8.png)->![](https://remnote-user-data.s3.amazonaws.com/MibyeH5bCReWpo1n-Vkkhd1Ojq9w6_xy4UfjQUU0MvE5DhMVQ0BlOusutTQKqeRuYZXrVhgPDsaxDjqP5rmNQkJk__T-7HKZ10QvT5rQVI_L68DT8VO4-dunOHMDQnKs.png)
            - Se emplea en utilidades concretas (debido a la información sobre la estructura que aporta el DFS) en algoritmos más avanzados *^Algunos al final del tema^(Puntos de articulación...).
            - Para muchos algoritmos es indiferente BFS y DFS.
        - 
        - # Recorrido en Anchura
            - El breath-first search(dfs) recorre la frontera en anchura.
            - Visita todos los vértices a una distancia k antes de descubrir el primer vértice a la distancia k+1.
            - Suele implementarse de forma iterativa.
            - Se tiene que incluir una cola con los vértices visitados para evitar ciclos y establecer el orden de la búsqueda.
            - Dado un grafo G=(V,E) y un vértice inicial S:
                - Calcula la distancia (menor número de vértices) desde S, hasta los vértices alcanzables.
                - Produce un árbol de recorrido en anchura donde la raíz es S.
                - Para cualquier V alcanzable desde S, la ruta en el árbol de recorrido de anchura de S a V es el camino más corto entre esos dos vértices.
                - Adecuado para dirigidos y no dirigidos. 
                - ### Pseudocódigo:
                    - BFS Iterativo (ra no llama a ra): (COLA no pila como DFS) 
                    - ![](https://remnote-user-data.s3.amazonaws.com/NRSfUddLc5Qo90FwcZ3I3lB8P4yQqzNEYs3K7CDxu9utJS_jqIhJuvUnbcS9iHmzimGPQ4pzFL3aKeyxQY9qOPpRpLI8iWDnYcqbZEqO0qDKgeTfGqNLXEDjnKZCmdmP.png)
                    - ![](https://remnote-user-data.s3.amazonaws.com/i_hr7_Mc5Nlw729VipmifA4L8XwlrCHkEUOza9j6rAf6eD1yauDvLXPQ-1n6V_mSEDl9d9de1tfjzc8Mtm9GeZUVIcbjBktcuMyc2vYjsw4-Y2TLwCOwb8CMowXrZdVr.png)
                - 
                    - 
                    - 
            - Complejidad = BFS -> $O(max(V,E))$
            - También genera árboles de recubrimiento. Si el grafo es conexo, solo uno.
            - Se emplea en exploraciones parciales de grafos, para hallar el camino más corto entre dos puntos de un grafo, etc...
            - Ejemplo recorrido en anchura:
                - ![](https://remnote-user-data.s3.amazonaws.com/mg1sU6bka5H6wEtOD3ftWrimlTWt2KM5IJLecVgAskWtkWdIaYVmrPNUDCA0Qncc0X_90zZDmcgeMAn5AKy6smDg2mGZrNudj_AYNdbP2mGSo02NSR5kHeeKCGMoazkY.png)
                - ![](https://remnote-user-data.s3.amazonaws.com/nOJc55iVSMrDLqwEkm6QDAOt-XVr0pIg0Q1jW3-fqgfz8U7JsYRAAu9W0mIUrUQW0NgIxoA72Cw0vBKkWwntDs_hp5gvkq7zxUUWGEUgxcn-qMeS2D2GFFMOzbPxiQGA.png)
        - 
        - # Algoritmos sobre grafos y Ordenación Topológica
            - ## Ordenación Topológica (Una de las aplicaciones de BFS/DFS):
                - Ordenamiento no comparativo, no se tiene orden total (a<b<c) se tiene un orden parcial (a<b, c<b, no tenemos relación entre a y c (a,c,b / c,a,b) -> Los dos serían ordenes válidos (Orden de vestirse)). 
                    - Aplicaciones teóricas:
                        - Tareas a realizar (algunas antes que otras).
                        - Makefile: algunas cosas se compilan antes que otras.
                        - Plan de estudios: Hay materias que deben hacerse antes que otras.
                        - ...
                - Opciones:
                    - Similar a recorrido BFS (basado en los grados de entrada de cada uno de los vértices(cuantas aristas le llegan)).
                    - ![](https://remnote-user-data.s3.amazonaws.com/dCJgL6w_l1OUJoUwGQzZUSRC4t5TCGxo_c7Ihl6FO8pMtcZixe3H_mN7U25IDg36kt4RiF8T3df4ZN1C0xxPnAby26oojm9S0Ar61uVz2MeZWR43oynsOcbq9vEU7mUa.png)
                    - Usando un recorrido DFS con muy poca modificación. (va recorriendo hasta que llega a un final, por ejemplo taller 1 en el grafo de arriba y lo mete en una pila, asegurando que salga el último * [puede empezar desde cualquier nodo]* ) *. * Si prefieres profundizar antes de meterte en otras cosas usa este (ej: Ver el universo Marvel acabando primero las de Spiderman que no tengan la condición de verse después que otra). 
                        - .
                            ```
                            #topsort recursive DFS
def topological_sort(graph):
    visited = set()
    result = []
    
    def dfs_topo(node):
        # Marcar como visitado
        visited.add(node)
        # No hay procesamiento aquí
        
        # Explorar vecinos
        if node in graph:
            for neighbor in graph[node]:
                if neighbor not in visited:
                    dfs_topo(neighbor)
        
        # Procesar el nodo en backtracking
        result.append(node)
    
    # Iniciar desde cada nodo no visitado
    for node in graph:
        if node not in visited:
            dfs_topo(node)
    
    # Invertir el resultado para obtener la ordenación
    return result[::-1]
                            ```
                - Dado un grafo dirigido y acíclico, se denomina ordenación topológica a una disposición lineal de los nodos tal que, dado un arco (u,v), el nodo u esté antes que v en la ordenación.
                    - Un vértice se visita sí y solo sí se han visitado todos sus predecesores.
                    - En caso de grafos con ciclos, el algoritmo sigue siendo válido, pero la interpretación no es directa.
                - Aplicaciones prácticas:
                    - Fases de un proyecto (PERT).
                    - Evaluación de atributos en la fase semántica de un compilador.
                - Ejemplo con recorrido en profundidad. Distancia y finalización.
                    - ![](https://remnote-user-data.s3.amazonaws.com/NBGIzEmGVLYLqgX2yA9jyVY3Pe1BC6byJfY56dPpnNxkLTJ4lnuOUNLp3ppYx54jEZZttQ12pnWjnZRQrUGnoVUoR6VcwCSc4-0_E_FN9ewnnRxl1Yw9di76FTyJC7Uq.png) ![](https://remnote-user-data.s3.amazonaws.com/KNbAwlh3VD-ktTp0729unsjprP2vEaw9Eow9DG3E6SpXs1KKh5cmUZlLS_59eeQiUfhJwbPvFihQr8o_uPXf6jY3qlc-P-8hKbvYnzI-BwmzoKB7Knn-gaZgDmxmXvto.png)
                    - ![](https://remnote-user-data.s3.amazonaws.com/MjlVSXJhT3E0cg73_1VGoRltjJXR9pi5_Is2QMc1ksQhoikAkK6GjmpL9tux_FjhM0o73siwLKhMMV86oPMCS2t2S89yHBJ824IrjfjfPxHHhn4YDt2BuzK5Zo_ireBr.png)
            - ## Algoritmos sobre grafos  *(Términos, procedimientos,...)* :
                - Un **grafo conexo** es un grafo no dirigido donde existe un camino entre cualquier par de nodos. Un **grafo fuertemente conexo** es un grafo dirigido donde existe un camino entre cualquier par de nodos, considerando la dirección de las aristas  s.
                - 
                - 
                - ara descomponer un grafo G en sus componentes fuertemente conexas:
                    - Aplicar la ordenación topológica sobre G.
                    - Calcular el grafo traspuesto G^T^  *(Invertir el sentido de los arcos)* .
                    - Aplicar DFS sobre G^T^ iniciando la búsqueda en los nodos de mayor a menor tiempo de finalización obtenidos en la primera ejecución de búsqueda en profundidad.
                    - El resultado será un bosque de árboles. Cada árbol es una componente fuertemente conexa.
                - **Puntos de articulación: **Un vértice V de un grafo conexo es un punto de articulación si el subgrafo que se obtiene al eliminarlo (Junto con sus aristas) no es conexo.
                - **Grafo biconexo****(o no articulado)**: aquél grafo que no tiene puntos de articulación.
                - **Grafo bicoherente (o 2-arista conexo): **aquél grafo cuyos puntos de articulación están unidos a cada componente del subgrafo restante por, al menos, dos aristas. 
                - Si el grafo representa una red de comunicaciones:
                    - Si es **biconexo ** nos asegura el correcto funcionamiento de la red, aunque falle uno de los equipos.
                    - Si es **bicoherente **nos asegura el correcto funcionamiento de la red, aunque falle una de las líneas de transmisión. 
                - ### Cálculo de los puntos de articulación g dirigido(Variacion del tarjan  *(tb:Algoritmo puntos articulación g no dirigidos y componentes fuertemente conexas)* DFS):
                    - ![](https://remnote-user-data.s3.amazonaws.com/2EuDoKYtFyo3gr5WEfqjam82HpY4-V5tK8VQIM4OkR01vOsShys5CucRH1hZO88rUuZq-YNZwHgGmR_a4ggbGHxP7IzkyVxUZhw6b2gvlwY3-b9bf4OUdXRKj_XSb4RB.png)
                    - Sea V cualquier vértice del árbol (excepto la raíz) y X un hijo de V:
                        - Si masAlto[X] < preOrden[V] implica que se puede llegar desde x a regiones más altas sin pasar por (V,U). Entonces U no es un punto de articulación. (con mis palabras: Si alguno de sus hijos, a través de sus hijos puede llegar a un nodo más alto, sin pasar por la arista del padre(él) al primer hijo, no es punto de articulación(los puentes con líneas intermitentes valen como camino de subida))
                        - Si preOrden[X] ≥ masAlto[V] no se puede llegar desde U a regiones más altas del grafo sin pasar por (V,U). Entonces U es un punto de articulación.
                    - Si U es la raíz del árbol y tiene más de un hijo, es un punto de articulación, si no, no.
                    - *****En el ejemplo anterior los puntos de articulación son 1 y 4, el 1 en el árbol del recorrido es la raíz del árbol y tiene 2 hijos, por lo que es **punto de articulación**, además, alguno(en este caso ninguno) de los hijos de 4 (7 en este caso), puede llegar a un nivel más alto que 4, por lo que 4 es **punto de articulación**. 
                    - Ejemplo de pseudo-código con DFS:
                        - ![](https://remnote-user-data.s3.amazonaws.com/mAEhhnKkI0VMwxIdyR9YqVoBjzQAkALknieIA3hZ4S8jR8o4jvN_uBrHDdkMs132szun5SdKgBWmdyXA3oUSsvHvnViGlCrZMorkhISi_Dkodzbx8kCAjVu3_rZ_hMK9.png)
                - Otras aplicaciones interesantes:
                    - Comprobar que un grafo es bipartito.
                    - Detectar ciclos en grafos.
                    - Camino más largo en un DAG.
                    - Determinar si dos nodos están conectados o no.
                    - Caminos y ciclos eulerianos
                    - Cierre transitivo.
                    - Caminos entre un origen y un destino con K aristas.
        - 
    - T3.-Algoritmos Voraces 
        - Greedy: Voraz, avaricioso, codicioso...
        -  *Dado un problema con n entradas, el objetivo es obtener un subconjuntos de estas, de tal forma que se satisfaga una determinada restricción de forma óptima.* 
        - La forma habitual de resolverlo:
            - Escoger las mejores entradas que verifiquen las restricciones hasta que se encuentra la solución que se busca.
        - Ejemplo:
            - Supongamos un país tiene un monedas con valores v~1~ ,v~2,...,~v~n~ .
            - Descomponer una cantidad dada M, en monedas, de forma que el número de monedas utilizadas sea mínimo.
                - Datos relevantes:
                    - **Candidatos:** Monedas C ={v~1~ ,v~2,...,~v~n~}.
                    - **Solución:** La suma de las monedas elegidas es igual al cambio. 
                    - **Factibilidad:** La suma de monedas no puede superar al cambio. 
                    - **Objetivo:** Minimizar las monedas devueltas. 
                    - **¿Selección? -> **Moneda de mayor valor mientras sea factible. 
            - ![](https://remnote-user-data.s3.amazonaws.com/fl48WiqhibIfEGUmVlPzNu4hXryvmvv47Cmo5JWLO10RKsHGiEUJGLc60uTQzgWtnSC2FOdY_yuH6pDURIimaHsa83DECvEjpvN1cQO3HMh3pUZ3YG7RREUVOoAAeYdV.png)
        - ## Identificar:
            - Conjunto de **candidatos **y conjunto de **seleccionados**.
            - Función de **selección**: elige el candidato idóneo en cada etapa.
            - Función **solución**: determina si los candidatos seleccionados son una solución.
            - Función de **factibilidad**: determina si el conjunto de seleccionados es prometedor.
            - Función **objetivo:** determina el valor de la solución. 
        - ## Esquema de la técnica:
            - ![](https://remnote-user-data.s3.amazonaws.com/EGh3Cl9KUR6ZZHJxFDFHDIQ_QF2RuohU1-5FBVTh-v2CB-Wrb8vvA8dZCJK5fbHEfu2t9i_WcJoNSLvfcuCLEBqwpNZhskQFBqEIcvM82roN7xqtVnJjpz9Nb2aKbpeT.png)
            - ## Características del esquema:
                - Se construye una solución **iterativamente.**. 
                - Se toma la decisión **óptima **en cada **iteración**.
                - Una vez analizado un candidato (introducir o excluir), **no se reconsidera ** la decisión.
                - Son voraces por que en cada etapa toman **la mejor decisión **sin preocuparse del mañana.
            - ## Ventajas:
                - Implementación sencilla.
                - Soluciones de forma muy eficiente (Complejidad polinómica).
                - Encuentran la solución óptima para un número determinado de problemas.
            - ## Desventajas:
                - No siempre encuentra la óptima (ej: cambio con monedas de 11, 5 y 1).
                - No reconsiderar decisiones pasadas puede conducir a no obtener el óptimo global (ej: problema del viajante).
                - Encontrar la función de selección que garantice la optimalidad.
                - Demostración formal de la optimalidad (encuentra el óptimo global).
        - ## Aplicaciones de los algoritmos voraces:
            - ### Minimización del tiempo en el sistema:
                -  Un servidor tiene que dar servicio a un cliente, el tiempo por cliente t ~i ~es conocido. Se desea minimizar el tiempo medio de cada cliente en el sistema.
                    - ![](https://remnote-user-data.s3.amazonaws.com/I_boIgyjZ3nY8U0VflDX2Rea8hWjFsz0nJzxJ3_SD6mKMwlfHK7AVxJ6G0rgbGkiEOOGlOucgl2jUuQ4zS5xfRwNRRTz9lNMz1XQ4Pl-GBTcotYkbW7prUzYzxi09USQ.png) 
                    - Como n es conocido, equivale a minimizar el tiempo total invertido por cliente en el sistema.
                    - ![](https://remnote-user-data.s3.amazonaws.com/zC7Xv_3fHuEp26GXWwmc_KvlvxAglNPm2H8qdHduOWkfBcbPKs9wucIMyyLPtqRveblbNnCfsbBENfz36nmcBssP45Ej7BmkfZ7PVz9YDzmHhdab794_JYEODu8bQ8Ie.png)
                    - Conjunto **candidatos**: **n** clientes. 
                    - Función **solución**: todos los clientes han sido ordenados.
                    - Función de **factibilidad**: si han sido ordenados los clientes o no.
                    - Función **objetivo**: minimizar T.
                    - Función de **selección**: Elegir los candidatos por orden creciente de t ~i.~
                - El algoritmo voraz se reduce a ordenar de forma no decreciente en t ~i~ los n clientes.
                - **Pseudocódigo:**
                    - [https://remnote-user-data.s3.amazonaws.com/Ij9MRqWYw9iJLouKYZyEKrhrQurFsc6SdMFYIv3mKkHMSritAXy4wijVi_OUtLMp3ktjzfl1wTQOmeu5PF7y8CY6emWTtYnt04P3__eX18_zJMy1YNGhP118ShZ-UuoD.png](../Uploaded%20Files/Tema3_DAA/Highlights/Page%2015/Untitled.md)
                - 
            - ### Problema de la mochila:
                - Tenemos n objetos y una mochila. Cada objeto i tiene un peso W~i~ > 0 y un valor V~i~ > 0. La mochila puede llevar un peso que no sobrepase W. Se desea llenar la mochila **maximizando** el valor de los objetos transportados.
                    - [https://remnote-user-data.s3.amazonaws.com/DZWsqk0yRMcUdLytzLiAo2vqNgy-GAdh7-R7szyJl7NRb--07Ko8-G0WiESYa0bl15Qm-MTjL9pERtB70iIZh_KjdxLxc96VU-g7uazHJGG8HPorjMldfJr4n8Jk_THc.png](../Uploaded%20Files/Tema%203_%20Algoritmos%20Voraces%20(Dise%C3%B1o%20y%20An%C3%A1lisis%20de%20Algoritmos)/Highlights/Page%2016/Untitled.md)
                - Con las restricciones:
                    - [https://remnote-user-data.s3.amazonaws.com/7aPAlsBRJ_wkmoe0PSbRqpAIcrejQXLd0OsDXQ7vyiW7PqgRCuu7cTQBLhcnB_X1DzdGjxPdR_P3QfqU0kd1QTAZ9_Qv2VEoYXxqdIGbTXyuoMpQoOS49H2jopUoJO27.png](../Uploaded%20Files/Tema%203_%20Algoritmos%20Voraces%20(Dise%C3%B1o%20y%20An%C3%A1lisis%20de%20Algoritmos)/Highlights/Page%2016/Untitled.md)
                    - Conjunto **candidatos**: **n** objetos. 
                    - Función **solución**: Cuando no puedan añadirse más fracciones de objetos a la mochila.
                    - Función de **factibilidad**: [https://remnote-user-data.s3.amazonaws.com/A8entDtsmOsOAvk-702qatsm3k3P60Zjqi-xsM7JOe14fdfBFzzGHQ7z7S-nD97hs3o3jNMtsVyZ3gTtMkmZGpwnFqV7HqnKca1bqAdlVTPR0D9Kec6xKPutJ-AjRnKo.png](../Uploaded%20Files/Tema%203_%20Algoritmos%20Voraces%20(Dise%C3%B1o%20y%20An%C3%A1lisis%20de%20Algoritmos)/Highlights/Page%2017/Untitled.md)
                    - Función **objetivo**: [https://remnote-user-data.s3.amazonaws.com/ZNN2pE91BkJqs7tU2ZGDo3Cw0pAbtXqF-ekL59q0yAFsm-lrV_0pgY9ZbO6Dk7SdDz8utJZsqzm6U697KfImZ4zmzNJVK81LeRSqiF-cgdJsev_RmDCHVlbLlQPmEBki.png](../Uploaded%20Files/Tema%203_%20Algoritmos%20Voraces%20(Dise%C3%B1o%20y%20An%C3%A1lisis%20de%20Algoritmos)/Highlights/Page%2017/Untitled.md)
                    - Función de **selección**: Elegir los candidatos por orden decreciente de V ~i.~
                    - Encuentra solución óptima si los objetos se pueden partir.
                - **Pseudocódigo:**
                    - [https://remnote-user-data.s3.amazonaws.com/PYe1r4MqnV0lZqGLXHbwNFP9RPgL5rXzvWpON1O3GwQNncZJheaoRLN1M6mIIR7rt9KOcLxW__HI4raTKBMrbDY294Eqm_aJ5fBMHdyFsO9Mu-3EWVd0usvH4QLQ-ls0.png](../Uploaded%20Files/Tema%203_%20Algoritmos%20Voraces%20(Dise%C3%B1o%20y%20An%C3%A1lisis%20de%20Algoritmos)/Highlights/Page%2019/Untitled.md)
            - ### Planificación con plazo fijo:
                - Tenemos n trabajos, donde cada trabajo i tiene una fecha tope de realización    f ~i~ > 0 y un beneficio b ~i~ > 0.
                    - Entonces:
                        - Para cualquier trabajo i, el beneficio b ~i~ se gana si y sólo sí se realiza antes (o coincidiendo) con su fecha tope f ~i.~
                        - El trabajo se realiza en una máquina que consume una unidad de tiempo y sólo hay una máquina disponible(i.e., en un instante de tiempo solo se puede ejecutar una tarea)
                    - Conjunto **candidatos**: **n** trabajos a realizar. 
                    - Función **solución**: cuando se hayan planificado todas las tareas.
                    - Función de **factibilidad**: conjunto T de trabajos que todavía se pueden completar antes de su tope.
                    - Función **objetivo**: [https://remnote-user-data.s3.amazonaws.com/_7uVxYu3ayUrUp5PLd7FaqC8Y_WAg3SwWIBtLIPyN8-IbXLhwNUgz385vaDO_p7aUv9iE_EsgRBgL0pIqkFysTnuT7OM5v6DnX0UotVRAcYO7CPDx_iufLY0twDthSht.png](../Uploaded%20Files/Tema%203_%20Algoritmos%20Voraces%20(Dise%C3%B1o%20y%20An%C3%A1lisis%20de%20Algoritmos)/Highlights/Page%2022/Untitled.md)
                    - Función de **selección**: considerar trabajos en orden decreciente de los beneficios~.~ 
            - **([HASTA AQUI EXAMEN PARCIAL 1 Jueves 27/3/2025])** 
            - ## Activity Selection.
            - ### [Problemas en grafos (árboles de recubrimiento y caminos más cortos).](Cuatrimestre%202/Dise%C3%B1o%20y%20An%C3%A1lisis%20de%20Algoritmos/T3.1-Algoritmos%20Voraces%20sobre%20Grafos.md) 
        - 
    - T3.1-Algoritmos Voraces sobre Grafos 
        - ## Introducción:
            - Árboles de recubrimiento (expansión/generador) mínimo:
                - Algoritmo de Prim.
                - Algoritmo de Kruskal.
            - Caminos mínimos:
                - Algoritmo de Dijkstra.
            - Heurísticas voraces:
                - Coloreado de grafos.
                - Viajante de comercio.
        - ## Árboles de recubrimiento mínimo:
            - **Problema:**
            - Dado el grafo G = (V,E) no dirigido y ponderado con pesos positivos, calcular el subgrafo conexo [T ⊆ G](../Uploaded%20Files/Tema3.1_DAA/Highlights/Page%2003/T%20%E2%8A%86%20G.md), que conecte todos los V del G y que la suma de las aristas seleccionadas sea mínima
            - **Solución:**
            - Si el grafo es conexo, el subgrafo resultante es necesariamente un árbol.
            - Estrategias para resolver el problema:
                - Seleccionar la arista **más corta **en cada iteración
                    - Algoritmo de Kruskal.
                - Seleccionar un **vértice al azar **y construir el árbol a partir de él, añadiendo las aristas de menor peso que tenga un extremo en la solución y otro no
                    - Algoritmo de Prim.
            - Aplicaciones:
                - Diseño de redes.
                    - Mínimo coste.
                    - Refuerzo de líneas críticas.
                    - Identificación de cuellos de botella.
                    - Enrutamiento (evitar ciclos).
                - Soluciones aproximadas a problemas NP.
                - Algoritmos de agrupamiento (clustering).
                - ...
            - Datos relevantes:
                - **Candidatos: c**onjunto de aristas E.
                - **Solución: **se ha construido un árbol con |V| vértices y |V|-1 aristas (extensible a grafos no conexos).
                - **Factibilidad: n**o existe ningún ciclo.
                - **Objetivo: **minimizar la suma de los pesos de las aristas seleccionadas.
                - **Selección: d**epende del algoritmo.
            - ### Algoritmo Kruskal O(|V| |E|):
                - Ordena las aristas de **mayor ** a ** menor **peso.
                - El árbol se construye a partir de ** varias **componentes **conexas**.
                - Sólo se incluye una arista si se une **dos **componentes **conexas**.
                - El algoritmo termina cuando sólo hay **una **componente **conexa**
                    - Encuentra la **solución óptima **al problema.
                - Ejemplo de Kruskal:
                    - [https://remnote-user-data.s3.amazonaws.com/tedtlFz5ZoLdpjLSWJyRqGp-mJlyPSmwExWjJKeU3b4cPrnv5vIh_hi5ucvjf0r2--JCXdnqZH4RdeIKr8t4jLePZ1qLO7RrPhCvTowqvstlzjNjzbYNq3sv5RVDnyte.png](../Uploaded%20Files/Tema3.1_DAA/Highlights/Page%2008/Untitled.md)
                - **Esquema:**
                    - [https://remnote-user-data.s3.amazonaws.com/bkSpVh2VnprfQr9DOhIynlmrZy5nRbWZ4fROm1cIVho6ZiqlmIPse2XCY29TQiuc6KMled4UVQ0EtQ9YWr3zu7FduLkI1YRuUc6qpecV9IHsTyGu5rp8JR4_YnJ4cq7h.png](../Uploaded%20Files/Tema3.1_DAA/Highlights/Page%2010/Untitled.md)
            - ### Algoritmo de Prim O(|V| |E|):
                - El árbol se construye a partir de una **raíz**.
                - En cada iteración se añade una nueva rama (arista) al árbol.
                - Sólo se incluye una arista si no **genera ciclos**.
                - El algoritmo termina cuando sólo se han añadido **todos **los vértices
                    - Encuentra la **solución óptima** al problema.
                - Ejemplo algoritmo Prim:
                    - [https://remnote-user-data.s3.amazonaws.com/nLvNAjAFohXBOE5odQ8eEcOCi4DWwBDQgiXPrKpxiJe1gw0STH-0TxzuzKMyrrFw9uDegdYKn7IJ9HL3J3LvzpussrQ251P2WjjL-AxZrxsPXxpbZQGmkfpAD47NjsGB.png](../Uploaded%20Files/Tema3.1_DAA/Highlights/Page%2013/Untitled.md)
                - **Esquema:**
                    - [https://remnote-user-data.s3.amazonaws.com/iEYOSgMiSTf-Cj7VhGnot9PnUgKnEIjzeR7d0AH3I3GZ3JCKjxLprYc0IGHW89gvZjq5mRNIwsiOlVYON9cye_4CNAe5NX-1BGbUy5Adjnp1s8nXADvwHlUnzo8Y0pRi.png](../Uploaded%20Files/Tema3.1_DAA/Highlights/Page%2014/Untitled.md)
        - ## Caminos mínimos:
            - **Problema:**
            - Dado un grafo conexo G = (V,E), dirigido y ponderado con pesos positivos, se toma uno, v, de los vértices como origen. El problema consiste en determinar la longitud mínima del camino que empieza en v hasta el resto.
            - Estrategias para resolver el problema:
                - Mantener un conjunto de nodos ya explorados para los cuales ya se ha determinado el camino más corto desde v
                    - Algoritmo de Dijkstra.
                - Propiedades de los caminos mínimos:
                    - Si d(v, u) es la longitud del camino mínimo para ir desde v a u, entonces se satisface:
                        - d(v, u) <= d(v, s)+d(s, u)
                - Datos relevantes:
                    - **Candidatos:** conjunto de vértices de los que se conoce la distancia mínima desde el origen.
                    - **Solución:** cuando no quedan candidatos.
                    - **Factibilidad:** siempre es factible.
                    - **Objetivo:** minimizar el camino de origen al resto de nodos.
                    - **Selección:** candidato con menos distancia al origen.
                - ### Algoritmo de Dijkstra O(|V|^2^)  :
                    - Se parte de dos conjuntos de nodos (V = S ∪ C)
                        - S: nodos seleccionados para los que se conoce el camino mínimo.
                        - C: resto de nodos del grafo.
                    - En cada iteración se escoge el nodo de C con menor distancia y se añade a S. Se recalculan los caminos a través del nodo seleccionado.
                    - Si no existe arista, se considera distancia infinita
                        - Encuentra la **solución óptima** al problema
                    - Ejemplo algoritmo Dijkstra:
                        - [https://remnote-user-data.s3.amazonaws.com/W44S_vO-mt_yqRZDDWIBkYnj5NAkgOA6x9hd1kNiSDCcgKQUb7nt2eL6NlGphBKXI4cvq0xDUl-6asj5YYBRgeZ2XSnKGwN_ILqxWJgwZ34LNNoBIos4VqTJG7Z4ZF-9.png](../Uploaded%20Files/Tema3.1_DAA/Highlights/Page%2020/Untitled.md)
                    - **Esquema:**
                        - [https://remnote-user-data.s3.amazonaws.com/Nr9ZrLvsGzjlG2PfsiJ5fj5mxXacWnFApQIs49LkhnQne10pX4hAqQ1NQQsMk5RMn5xnhq_Zw2gPZucH0Er3azfnLT18yowql7ved-iPKybfH2BEjiQX_wBI-JXqCsID.png](../Uploaded%20Files/Tema3.1_DAA/Highlights/Page%2021/Untitled.md)
        - ## Heurísticas voraces:
            - **Problema del coloreado de grafos: **Dado un grafo G = (V, E) no dirigido, asignar un color a cada vértice de tal forma que dos adyacentes no tengan el mismo color.
            - **Objetivo:** Minimizar el número de colores utilizados.
            - **Problema NP: **no existe ningún algoritmo eficiente que garantice un número mínimo de colores para grafos generales
                - Grafos planos: **4 colores** (Teorema de Appel-Hanke)
                - ![](https://remnote-user-data.s3.amazonaws.com/OL9P4-s1cuvrKWIroYL2_OX4tP4I7a1OluDB20_orgHmNXGqHhxLhBTOAMIv_5ZwBzx9emZ2K1QhGXNsY8M7eS2c_rZmiHmMbKfqIlc3D9TPEpYZ6OAP_ETG0HAzBF-M.png)
                - ![](https://remnote-user-data.s3.amazonaws.com/LuU9Fa3XMMHrPgRZgyXqbgVRugAl2iq9G6RuKHWiThNVriOVjEI3VMyyzXFKtlv-2OWxoaARlXU_1p9RoQaGB3Ud6n-Y6VGciF3RUL2ZqBrHwVrKoMPb8CPvbPiN5Mgl.png)
                - 
            - **Problema del viajante: **Dado un grafo G = (V, E), encontrar un camino que empiece y acabe en un vértice v, pasando una única vez por cada vértice de V.
            - **Objetivo:** Obtener el circuito hamiltoniano de coste mínimo.
            - **Problema NP:** no existe ningún algoritmo eficiente que garantice la optimalidad 
                - ![](https://remnote-user-data.s3.amazonaws.com/YGRkIeXcSpE0uz_RWtzvDWMjdFXgQABCBP85LfD1NgKCt6jVnN78lnAemATgELhgDlxg4XWAjAi8-FzzDw63Au8eAI-1Mom6ei_cB7593T8PEinYq2IE-3lNDH9shLWu.png)
                - **Heurística 1: **escoger en cada iteración el vértice más cercano al último nodo añadido al circuito siempre que:
                    - No se haya seleccionado previamente
                    - No se cierre el circuito
                - **Heurística 2: **escoger las aristas de coste mínimo (como en kruskal) pero garantizando que al final se forme un circuito. 
- # Evolución y Adaptación del Software 
    - Índice EAS
        - #  _**Fechas relevantes:**_  
            - ## Exámenes:
                1. Examen de teoría(40%) (min: media de 4/10 con examen problemas) - Ordinaria
                2. Examen de problemas(20%) (min: media de 4/10 con examen teoría) - Ordinaria
            - ## Prácticas:
                1. Práctica obligatoria entrega final(20%) (min: media de 4/10 con control de versiones) - Todo el curso
                2. Sesiones prácticas seguimiento de control de versiones(20%) (min: media de 4/10 con práctica) - Todo el curso
        - 
        - #  _**Profesorado:**_ 
            - ### Prof. Carlos E. Cuesta

                - **Despacho:** 048, Departamental II, Campus de Móstoles
                -  **Contacto: **A través de la herramienta Correo del aula virtual o enviando un correo electrónico a la dirección [carlos.cuesta@urjc.es](mailto:carlos.cuesta@urjc.es).
            - ### Prof. José Manuel Puerta Peña
                - **Despacho:** 205, Laboratorios III, Campus de Móstoles
                -  **Contacto:** A través de la herramienta Correo del aula virtual o enviando un correo electrónico a la dirección [josemanuel.puerta@urjc.es](mailto:carlos.cuesta@urjc.es).
        - 
        - #  _**Índice:**_ 
            - ### Bloque I. Introducción al mantenimiento y evolución del software
                - Tema 1. Evolución y Mantenimiento del Software
                - Tema 2. Leyes de Lehman
            - ### Bloque II. Gestión de la configuración del software
                - Tema 3. Gestión de la Configuración del Software.
                - Tema 4. Sistemas de Control de Versiones
            - ### Bloque III. Técnicas de Evolución del Software
                - Tema 5. Principios de Diseño de Software 
                - Tema 6. Reingeniería del software 
            - ### Bloque IV. Tendencias en Evolución y Adaptación de Software
                - Tema 7. Contenedores. Arquitecturas de Microservicios 
                - Tema 8. Diseño Dirigido por el Dominio (DDD)  
- # Metodología de la Programación 
    - Ínice de MP
        - #  _**Fechas relevantes:**_  
            - ## Exámenes:
                1. Parcial T3 - T6: 21 de Marzo (25%)(min:5/10)
                2. Parcial T1,T2 y T7: 23 de Mayo (25%)(min:5/10)
                3. Autoevaluaciones T1 - T7: 9 de Mayo (10%)(min:0/10)
            - ## Prácticas:
                1. Fase Análisis: 20 de Febrero (10%) (min:5/10)
                2. Fase Diseño: 6 de Marzo(10%) (min:5/10)
                3. Fase Codificación: 27 Marzo(10%) (min:5/10)
                4. Fase Pruebas: 10 de Abril (10%) (min:5/10)
        - 
        - #  _**Profesorado:**_ 
            - **José David Villanueva García **
                - Despacho:
 205
 –
 Laboratorios
 III
                - Email: [**josedavid.villanueva@urjc.es**](mailto:josedavid.villanueva@urjc.es) 
                - Tutorías: solicitar cita previa por email especificando que la asignatura es MP o por el aula virtual.
            - **José Manuel Valero**
                - Despacho:
 -
                - Email: [**josemanuel.valero@urjc.es**](mailto:josemanuel.valero@urjc.es) 
                - Tutorías: solicitar cita previa por email  especificando que la asignatura es MP o por el aula virtual.
        - 
        - #  _**Índice:**_  
            - ## Bloque I: Especificación y derivación formal
                - Tema 1: Especificación formal de problemas
            - ## Bloque II:
                - Tema 2: Introducción a la verificación formal de programas
            - ## Bloque III:
                - [Tema 3: Metodología y ciclo software](Cuatrimestre%202/Metodolog%C3%ADa%20de%20la%20Programaci%C3%B3n/T3.-Metodolog%C3%ADas%20y%20Ciclo%20software.md) 
                - [Tema 4: Fase de análisis](Cuatrimestre%202/Metodolog%C3%ADa%20de%20la%20Programaci%C3%B3n/T4.-Fase%20de%20An%C3%A1lisis.md) 
                - [Tema 5: Fase de diseño](Cuatrimestre%202/Metodolog%C3%ADa%20de%20la%20Programaci%C3%B3n/T5.-Fase%20de%20Dise%C3%B1o.md) 
                    - [Tema 5.1: Patrones de Diseño](Cuatrimestre%202/Metodolog%C3%ADa%20de%20la%20Programaci%C3%B3n/T5.1.-Patrones%20de%20Dise%C3%B1o.md) 
                - Tema 6: Fase de codificación
                - Tema 7: Fase de pruebas de Software
        - 
        - 
        - 
    - T3.-Metodologías y Ciclo software
        - # Metodologías
            -  **Definición:** Conjunto de métodos que se utilizan en una determinada actividad con el fin de formalizarla y optimizarla.
            - Que hacer como y cuando durante el desarrolla y mantenimiento del proyecto
        - 
        - # Ciclo de Vida
            - **Definición: **Conjunto de fases por las que pasa un sistema que se está desarrollando desde que nace su idea hasta que el software es retirado o reemplazado.
            - Debe definir los siguientes aspectos:
                - Orden de las fases del proceso software.
                - Establecer criterios de transición entre una fase y la siguiente.
                - Definir las entradas y salidas de cada fase.
        - 
        - # Tipos de Metodologías
            - ### Pesadas o tradicionales:
                - Fases bien definidas, entregas al final, requisitos y planificación bien definidos.
            - ### Metodologías ágiles:
                - Continua interacción con el cliente, muchas entregas parciales y ciclos iterativos más cortos.
            - ### Metodologías centradas en el usuario:
                - El enfoque y la interacción está en el usuario, pero las características prioritarias son usabilidad y accesibilidad.
        - 
        - # Metodologías Tradicionales:
            - ## Ciclo de vida en cascada clásico:
                - ![](https://remnote-user-data.s3.amazonaws.com/ocWrVdK-6I9I8TpzTytPdkzLEfjUxPOu8zEjA_rvrPQeSQeV0PFy2nRwv_IrnMZWBDjt4J0g4ch5w1PcSBYFG3gVyi2M67iSjI4TsZyKQ9KlwsjqD4d7M9pJhNLLz-rR.png)
                - Proceso de desarrollo es una sucesión de etapas que exporta productos intermedios.
                - Deben desarrollarse todas las fases para que el proyecto tenga éxito.
                - Las fases continúan hasta que los objetivos se han cumplido.
                - Si se cambia el orden de las fases el productos es de menor calidad
                - ### Limitaciones:
                    - No se permiten iteraciones.
                    - Los requisitos se congelan al final del proyecto.
                    - El producto no es enseñable hasta el final del proyecto
        - 
        - # Metodologías Ágiles:
            - ### Características:
                - Prioriza la satisfacción del cliente a través de las entregas continuas de evaluables.
                - Mejora motivación del equipo.
                - Los cambios en los requisitos son bienvenidos en cualquier fase.
                - Las entregas software son frecuentes.
                - Interesados y desarrolladores deben trabajar juntos.
                - Los equipos reflexionan a intervalos frecuentes sobre como ser más eficaces.
            - Las mas usadas son:
                - XP (eXtreme Programming)
                - SCRUM
                - KANBAN
            - ## Metodologías Ágiles (SCRUM):
                - Se basa en **sprints: **iteraciones de desarrollo de duración recomendada 2-4 semanas:
                    - Durante cada sprint, el equipo desarrolla un incremento del software entregable.
                    - Existe un Product Backlog que contiene los requisitos de alto nivel priorizados y que definen el trabajo a realizar.
                    - Existe una reunión de Sprint Planning donde se seleccionan (el Product Owner) los requisitos de alto nivel en los que se trabajará en el siguiente sprint.
                - Se centra en entregables pequeños y concretos trabajados por orden de prioridad.
                - Roles principales:
                    - **Product owner:** la voz del cliente, conoce las prioridades del proyecto, organiza y administra las tareas a realizar.
                    - **Scrum master:** asegura el seguimiento de la metodología guiando a los demás en la forma de actuar en cada fase
                    - **Scrum Team:** son los responsables de desarrollar las tareas asignadas.
                - 
                    - 
                        - ### Ventajas
                            - Flexibilidad a cambios.
                            - Reducción del Time to Market.
                            - Optimiza el proceso.
                            - Alcance viable.
                            - Mayor productividad del equipo.
                            - Reducción de riesgos.
                    - 
                        - ### Desventajas
                            - Equipo auto-organizado(Puede ser ventaja pero tiene riesgos).
                            - Necesitas fuerte compromiso del equipo.
                            - Y del cliente.
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
    - T4.-Fase de Análisis
        - ![](https://remnote-user-data.s3.amazonaws.com/ltjulH-gEf17q_36ptMn59AnWh5Bmf4ef4t6nN7GenPt6lOGF1X25m6W-2XI2_iNCvZpBiSg2NJMuT5AuSKK1C1_G2AXqOolf_v-YXgi5czdI-nlhsmOAC2bqkMWAHQc.png)
        - # Fase de análisis
            - ![](https://remnote-user-data.s3.amazonaws.com/x5iTn5YB_rNbPx-__fNGfvZyKAxZI2tJ6S0vwLBPfvsii3jrmRQ-qAdYYk8opU_acazqsByvZXxCt2vWUQFA3DLG_jKNLNqowIjg7SHcb6OmQKDC-odrqzBhS3buO8Od.png)
            - El objetivo es extraer los requisitos.
            - Análisis del problema y especificación completa del comportamiento externo, los flujos de información y control del sistema software a construir.
            - Es importante ya que errores en esta fase pueden generar un producto que no satisfaga las necesidades de los usuarios.
            - Los requisitos se determinan siguiendo una aproximación descendente.
            - Se debe separar el qué del cómo.
            - ### Tareas:
                - **Educción de requisitos:** Identificar los requisitos que se obtienen de los usuarios. (Reuniones, brainstorming,...)
                - **Análisis de los usuarios y de las tareas: **Identificar potenciales usuarios, su jerarquía y tareas a realizar.
                - **Análisis del problema y sus requisitos: **Razonar sobre requisitos extraídos.
                - **Representación (modelización): **Registrar los requisitos en lenguaje formal, UML, maquetas...
                - **Validación: **Examinar las inconsistencias entre requisitos. 
        - ## Educción de requisitos:
            - Análisis del problema.
            - Identificar usuarios potenciales.
            - Identificar fuente de datos.
            - Recompilar info y hechos.
            - Preguntas y cuestiones concisas y directas
            - Analizar la información obtenida.
            - Priorizar
        - ## Tipos de requisitos
            - ### Funcionales
                - Acciones fundamentales que tiene que hacer el sistema
            - ### No Funcionales:
                - Requisitos de interfaz: menús, ventanas, mensajes error...
                - Requisitos operacionales: modos de operación, back-ups...
                - Requisitos de documentación: idiomas, ayuda online...
                - Requisitos de seguridad: nivel de acceso...
                - Requisitos de portabilidad y mantenimiento
                - Requisitos de recursos: memoria, almacenamiento...
                - Requisitos de rendimiento: tiempo de respuesta, nº usuarios...
        - ## Análisis de requisitos
            - ### Qué:
                - Proceso mediante el cual se determina qué requisitos son aceptables y se definen los que van a ser parte del producto.
            - ### Cómo:
                - Evaluación de la viabilidad técnica y económica.
                - Valoración de riesgos.
                - Clasificación de requisitos en: Obligatorios, deseables...
        - ## Representación de requisitos
            - ### Qué:
                - Proceso de registrar los requisitos de una, o mas formas.
            - ### Cómo:
                - Lenguaje natural: Catálogo de requisitos.
                - Lenguaje formal.
                - Modelos.
                - Diagramas.
                - Maquetas
                - ...
            - Especificación en lenguaje natural:
                - Se expresan de forma individual, organizados jerárquicamente y pueden numerarse.
                - Claros y concretos (Sin ambigüedades ni puntos suspensivos...)
                - Completos y consistentes
                - Indican lo que se espera que haga el programa, su justificación y en su caso, criterios de verificación aplicables.
            - Los requerimientos funcionales:
                - Redactados de tal forma que sean entendibles por usuarios no técnicos
                - Deben de especificar el comportamiento externo del sistema, y evitar si es posible, establecer características de su diseño.
                - Se pueden numerar para establecer una prioridad (pero siempre distinguirse entre obligatorios y deseables).
            - Los requisitos no funcionales:
                - Se expresan cualitativamente. siempre que sea posible (Verificación de su cumplimiento).
    - T5.-Fase de Diseño
        - ![](https://remnote-user-data.s3.amazonaws.com/uL1YfGB9EC4J_eH9IYPzgE1o0Jez9lWmV5Ji5X-q0yJaYL--W2HGWbroZjr916u5UZ2Tl4igZtF9uTcQ-mnkIzn-ojYnUKOruBsfkQyBjVdtds7c-O4-_SR5vPBF1swR.png)
        - # Fase de diseño
            - Proceso de definición de arquitectura, componentes, módulos, interfaces, procedimientos de prueba y datos de un sistema sw para satisfacer unos requisitos especificados.
            - Se pasa del qué al cómo:
                - ¿Qué hay que hacer? -> Especificación de requisitos.
                - ¿Cómo hay que hacerlo? -> Especificaciones de diseño
            - Existen dos niveles de diseño:
                - De alto nivel
                - De bajo nivel
            - La idea es ir detallando cada vez los aspectos del softwares que vamos a realizar
            - Para ello usaremos UML
        - # Unified Modeling Languaje (UML)
            - Antes: guerra de métodos, mismos conceptos distinta notación, confusión ->
                - 1994: Booch, Rumbaugh y Jacobson unifican métodos (UML)
            - ## Ventajas de UML:
                - Reúne los puntos fuertes de cada método
                - Idea nuevas mejoras
                - Proporciona estabilidad al mercado
                    - Proyectos basados en lenguaje maduro
                    - Aparición de potentes arramientas
                - Eliminar la confusión de los usuarios
            - ## Objetivos en el diseño de UML:
                - Modelar sistemas de requisitos a artefactos ejecutables, utilizando técnicas de OO(Orientación a objetos).
                - Cubrir cuestiones relacionadas con el tamaño de sistemas complejos y críticos.
                - Utilizable por personas y máquinas
                - Equilibrio entre expresabilidad y simplicidad
            - ## Tipos de diagramas:
                - ### Modelado de la estructura:
                    - Diagrama de clases
                - ### Modelado de comportamiento:
                    - Diagrama de Transición de Estados.
                    - Diagrama de Secuencia.
                - ### Matriz de trazabilidad
        - ##  _Diseño UML_ :  
            - ## Modelado de la estructura: -Diagrama de clases:
                - ### Herencia: 
                    - Son jerarquías de especialización de clases.
                    - Se heredan las propiedades y operaciones
                    - ![](https://remnote-user-data.s3.amazonaws.com/J0JpUL9hZzabN4rRVjHnC-OpoZ_oitaRkLctJsWQvBo7BQDOlXMNEKGkW8bVIqs4F72sODhdJjl2RTME6cvSQPunHOXcyr8fp9eayMxkkmBBOYoXvk9vspc8KS_WgDO8.png)
                    - 
                        - 
                            - ![](https://remnote-user-data.s3.amazonaws.com/Gd03aMuCD6sNrxuGFN3B5h8D8T8737AIzk9UjdxstoH0qMQs5A5U7aDYnIXuT_IL3SFGu7c_OnpfJ-Npuvf94FV92DSC-iMh-xVGD7Ck-7vib6_-ETGbfTiM4dzDvuPr.png)
                        - 
                            - ![](https://remnote-user-data.s3.amazonaws.com/B5-et5uF5wpIcNYmAa81skksjVWYFMLf-tS9o8DPW2qkYc1TKxmqhgONTwfQOJ5s7gVGsS2OCWOpW0-yxZXKp8itae3-iuYPhP_m_cD-4RalgqmmzsgIZ-Yph1EFEl1r.png)
                - ### Clases Abstractas:
                    - Una clase abstracta no puede instanciarse
                    - ![](https://remnote-user-data.s3.amazonaws.com/xjrN1-kA8mDufR-0rKXw3Zyw2rjxF8HvtT2EnTTbHBRCpjSNtq9_YCijl_3m-oApJUKciON46nmQV9EU2OjIGjx9w1VaavyGxkQfYLbWbBCicL1ODBMYBRGfZmVjRwSY.png)
                - ### Herencia Múltiple:
                    - Una clase puede heredar de varias.
                    - No es posible en Java, pero sí en otros lenguajes como C++
                    - ![](https://remnote-user-data.s3.amazonaws.com/WlPOBf4fbvYZOU9oYn_uQjTKC_4Q4pRW2Do5a8OPFK39DjLnxj3nvOBwlvQ0WqM5GarRgqmyCAopZaWpLrRdTjo3avzpdglrYlfoJFeJFLJQd_0BeS3csih1EF__hjj1.png)
                - ### Asociaciones:
                    - Los objetos no están aislados, si no que necesitan "conocerse", para poder invocar métodos de otros objetos.
                        - Esta funcionalidad se implementa mediante colaboraciones de objetos.
                    - Conceptualmente se representa mediante un enlace (línea) entre dos clases.
                        - En programación, esto significa que un objeto tiene una referencia a otro objeto (un atributo).
                    - **Multiplicidad**:
                        - Con cuantos objetos de destino se puede relacionar un objeto fuente, y viceversa.
                        - ![](https://remnote-user-data.s3.amazonaws.com/COqaOobI56jObs2-5qTDsrTOze_H6hZisF4koSUewW9JFgMbHRgdHaEaCBGlnLd1i6b2evTnc8rRFw-p66BmAgAzlq7X_OWVsBGEyr32QVjyHp9VHsq6g3GLIHEUILGq.png)
                    - **Roles**:
                        - Nombres en los extremos de las asociaciones.
                        - ![](https://remnote-user-data.s3.amazonaws.com/WC_5Gnb88GIEPBHJ8rZYLLxKBpXPzTgmnRfXD4mtucy3YKi1DRcDBKUg4S0B7bWUaqp7fWeLMKAFA1hjJdb4sHhhzpZUjCs3La7XjnA1J1qtKXsMb1UqXr9PX9BtnOci.png)
                    - **Navegación**:
                        - Indica si un objeto puede acceder a otro.
                        - ![](https://remnote-user-data.s3.amazonaws.com/kD27p_VfishgigkeXybzkXpk4rro8AWaTztHGMjGhZJToXqtNLKtM38FC3mtzCO2F5TfNTPW5ISKy8v5xYvLCVPmniR8bmlMBt41ELaJXzrXECm-ffDbYXLn0ETQMw4r.png)
                    - **Herencia de asociaciones:** 
                        - Una asociación declarada de una clase base, se hereda en las clases hijas:
                        - ![](https://remnote-user-data.s3.amazonaws.com/J0iZH0cGVKm9UPfjE38L7McOmGcGt0mdE0Cw-sadTindhKB4iMCW7r71PiSyfLrt9IJo9kWA2QWlP9_ihCfXndkVTz-7PMEKzzmg6oaBsPbW0sAmoKpzBJo-v4XeTw7C.png)
                    - **Composición y Agregación:** 
                        - Relaciones con semánticas especiales:
                            - $\blacklozenge$ **Composición**: La vida de la clase contenida debe coincidir con la vida de la clase contenedor (Composición fuerte). Los componentes constituyen parte del objeto compuesto. De esta forma, los componentes no pueden ser compartidos por varios objetos compuestos. El diamante negro se coloca en el extremo de la clase que representa el "todo" (el compuesto).
                            - ![](https://remnote-user-data.s3.amazonaws.com/8CyOO8PdSjwOgdErufdVQdBgNq-6DvjFlwxLM4pdY1_VWxicR25_WYGrZxgsNDsrphfyc6nTLUtMWCsJ5cKJ_eKLti_KnURUeg_Y6XtVK3i0bXZC9nWkaptcch7gmK6f.png)
                            - $\Diamond$ **Agregación**: La agregación es un tipo de asociación que indica que la clase es parte de otra (composición débil). Los componentes pueden ser compartidos por varios compuestos (de la misma asociación de agregación  o de agregaciones distintas). La destrucción del compuesto no conlleva la de los componentes, el diamante blanco se coloca en el extremo de la clase que representa el "todo" (el compuesto).
                            - ![](https://remnote-user-data.s3.amazonaws.com/3zMCcbI5nfL18720JVLqjZibO9EgeKsbpTjRUlTJoN2IVrmHuIvvL_DVp26iIUo6Wqwtt-Zjc3leYurpJevmy3Vp99skzH2vE6cMvwsmbqCyBBIkWY_3ZWQWPSFLSRMz.png)
            - ## Modelado de comportamiento:
                - Un diagrama de clases nos dice la estructura de la aplicación, pero no el comportamiento:
                    - ¿Qué hace cada método?
                        - **-**Pseudocódigo.
                        - **-**Diagrama de actividad.
                    - ¿Cómo cambia el estado de un objeto ante invocaciones de métodos?
                        - **-**Diagrama de transición de estados (statecharts).
                    - ¿Cómo colabora un conjunto de objetos para realizar una tarea?
                        - **-**Diagramas de secuencia. 
                - ## Diagrama de Transición de Estados:
                    - Van asociados a una clase.
                    - Describen cómo evoluciona cuando se le invocan métodos.
                    - Similar a un autómata finito.
                    - ![](https://remnote-user-data.s3.amazonaws.com/5kpHkiMRGvK76MjGQTwLMTs41Q6ORonjc2MzcSwZVsNSQ2kNq_MJLSG4eoQkjfNrLHd6W4YZVr6N1uODeVURIWxIvEDNbNDLX1n3gMJwin1iczhGda5Yg2qrEKXeGTKP.png)
                    - Estados jerárquicos.
                    - Guardas y acciones en las transiciones.
                    - ![](https://remnote-user-data.s3.amazonaws.com/pMOgRvRZiiAIeIz2VC1MQ5L1jLYP82LoGi7NsG9jVHT1zUP2G_YWk3HLLBrXc-hh7Yr9YHasrOO3ak20k1E-Et-Qnbphii95WuzKPBsMItGQxtWATEtX79t56yUdybL8.png)
                - ## Diagrama de Secuencia:
                    - ![](https://remnote-user-data.s3.amazonaws.com/nnlihMSbmZnCuJ-tAEGBMRXECt2Cmb6nVF7U-psSIclxbAdk3VZ1uPmGcZO2OyJ0oMl7vVgNgzwGnbspBoC2ZqBRsOnsiWUKm_1DGC9tQ4fI97IgNRx2QmW5Vp_byfdD.png)
                    - ![](https://remnote-user-data.s3.amazonaws.com/vQL1yqci-BzEHRLhRyW3Uu2DCd1Bkfhoa-ngaQNZIVHvAHNuoXgwjDRgn-62IczHUaycKw6fDT3Fsp1i1k6b5MMh8XduN5147LSK8kS4_SaOoavMGdhoFhY--I9dM5j0.png)
                    - ## Diagrama de Secuencia (Operadores):
                        - ![](https://remnote-user-data.s3.amazonaws.com/lRl4cBO6pczpfPV9g7DHmPYkeT7uM7tPJ_UGq-hlcYVkpW2T6aUbY9INWiaNN2YuTAO06V8ZwDkbjzVTKYKIN2K2wD7B9oRdBHAGW7k4sX1uilA3THFqpfC3Z87v6Ejx.png)
                        - **Alternativa (alt): **Elección (mediante una guarda) de una interacción. Múltiples fragmentos, sólo se ejecuta el que cumple la guarda.
                        - **Opción (opt): **Equivale a un operador alt con un solo fragmento. Equivalente al if en programación.
                        - **Bucle (loop): **El fragmento se ejecuta múltiples veces. La guarda indica como realizar la iteración.
                        - Existen otros como neg, par, critical, ref...
            - ## Matriz de trazabilidad:
                - Al finalizar el diseño (detallado) de la app, es necesario comprobar que todos los requisitos educidos en la fase de análisis tienen su correspondiente representación en el dominio de la solución a implementar:
                - 
                    - 
                        - 
                    - 
                        - **Elementos funcionales** 
                - 
                    - 
                        - **Requisitos ** 
                        - Requisito 1
                        - Requisito1.1
                        - ...
                        - Requisito N
                        - Requisito N.M
                    - 
                        - Clase1Metodo1
                        - X
                        - 
                        - 
                        - X
                    - 
                        - Clase1Metodo2
                        - X
                        - X
                    - 
                        - ...
                    - 
                        - ClNMetM
                        - 
                        - 
                        - 
                        - X
                        - X
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
        - 
    - T5.1.-Patrones de Diseño
        - # Patrones de diseño
            - Los patrones de diseño son soluciones habituales a problemas comunes en el diseño del software. Cada patrón es como un plano que se puede personalizar para resolver un problema de diseño particular en tu código.
            - Estos pueden clasificarse según su propósito:
                - Los **patrones creacionales **proporcionan mecanismos de creación de objetos que incrementan la flexibilidad u la reutilización del código existente.
                - Los **patrones estructurales **explican cómo ensamblar objetos y clases en estructuras más grandes a la vez que se mantiene la flexibilidad y eficiencia de la estructura
                - Los **patrones de comportamiento **se encargan de una comunicación efectiva y la asignación de responsabilidades entre objetos.
        - #  _Patrones Creacionales:5_  
            - ## Abstract Factory:
                - Es un patrón de diseño de creación que te permite producir familias de objetos relacionados sin especificar sus clases concretas.
                - **Estructura: **
                    - Los productos abstractos declaran interfaces para un conjunto de productos distintos pero relacionados que conforman una familia de productos.
                    - Los productos concretos son diversas implementaciones de productos abstractos, agrupados por variantes. Cada producto abstracto (silla/sofá) debe implementarse en todas las variantes dadas (Victoriana/Moderna).
                    - La interfaz Fábrica Abstracta declara un conjunto de métodos para crear cada uno de los productos abstractos.
                    - Las Fábricas Concretas implementan los métodos de creación de la Fábrica Abstracta. Cada fábrica concreta responde a una variante específica de los productos y crea solo esas variantes de productos.
                    - Aunque las Fábricas concretas instancian productos concretos, las firmas de sus métodos de creación deben devolver los productos abstractos correspondientes. Así el código de el cliente que utiliza la fábrica no se acopla a la variante concreta del producto que obtiene de una fábrica. El cliente puede trabajar con cualquier fabrica concreta/variante de producto, siempre que se comunique con sus objetos a través de interfaces abstractas.
                    - ![](https://remnote-user-data.s3.amazonaws.com/2_dmoXjOfugkaDmVUw8TsXnEZsLWnTmhZ_pOhDKN3QIiyPkTsmx2bvTo-CxK6_w3mbe97FYmQyMhT0acdQ3Le-733BmtRb9cTi5qUlOhBR5v5P99FFRGtgdAJdmk5FCB.png)
                - Utiliza Abstract Factory cuando necesites trabajar con varias familias de productos relacionados, que no quieras que depena de las clases concretas de esos productos. Evita la creación de variantes incorrectas.
                - Cuando una clase se encarga de varios tipos de productos, puede merecer la pena extraer sus métodos de fábrica en una clase fábrica independiente o en una implementación de Abstract Factory.
            - ## Factory Method:
                - El método de fábrica es un es un patrón que proporciona una interfaz para crear objetos de una superclase, pero permite a las subclases modificar el tipo de objetos que se crean.
                - **Estructura:**
                    - El producto declara la interfaz, que es común a todos los objetos que pueden ser producidos por el creador y subclases.
                    - Los productos concretos son diferentes implementaciones de la interfaz producto.
                    - La clase Creador declara el método de fábrica que devuelve nuevos objetos producto. El tipo de retorno de este método ha de coincidir lo con interfaz del producto.
                    - Puedes declarar el método de fábrica como abstracto para forzar a todas las subclases a implementar sus propias versiones del método, como alternativa el método base puede devolver algún tipo de producto por defecto.
                    - El método de fábrica no tiene que crear nuevas instancias todo el tiempo, puede devolver objetos existentes de una caché u otro sitio...
                    - ![](https://remnote-user-data.s3.amazonaws.com/5aJ3rPUvpu_5p3zzTs9dIm7w5NkrocDkxFam10JclBmNaLjTSMd5VFYzcz71-Q3EVZoCnc1gQfGLh4YDxjJcChG6IsL4GtdsCwl1d5tE3CYCjwsgP0QREpkdcDLj7ntz.png)
            - ## Builder:
                - Permite construir objetos complejos paso a paso. El patrón permite producir diferentes tipos y representaciones de un objeto utilizando el mismo código de construcción.
                - 
            - ## Prototype:
            - ## Singleton:
        - #  _Patrones Estructurales:7_  
            - ## Adapter:
            - ## Bridge: 
            - ## Composite:
            - ## Decorator:
            - ## Facade:
            - ## Flyweight:
            - ## Proxy:
        - #  _Patrones de comportamiento:10_  
            - ## Chain of responsibility:
            - ## Command:
            - ## Iterator:
            - ## Mediator:
            - ## Memento:
            - ## Observer:
            - ## State:
            - ## Strategy:
            - ## Template Method: 
            - ## Visitor: 
        - 
