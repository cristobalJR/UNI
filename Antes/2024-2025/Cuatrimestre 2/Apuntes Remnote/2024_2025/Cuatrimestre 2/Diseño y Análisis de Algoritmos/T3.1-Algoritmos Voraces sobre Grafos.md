- ## Introducción:
- ![[PrimAnimation.html]]
    - Árboles de recubrimiento (expansión/generador) mínimo:
        - Algoritmo de Prim.
        - Algoritmo de Kruskal.
    - Caminos mínimos:
        - Algoritmo de Dijkstra.
    - Heurísticas voraces:
        - Coloreado de grafos.
        - Viajante de comercio.
- ## Árboles de recubrimiento mínimo:
    - **Problema:**
    - Dado el grafo G = (V,E) no dirigido y ponderado con pesos positivos, calcular el subgrafo conexo [T ⊆ G](../../../Uploaded%20Files/Tema3.1_DAA/Highlights/Page%2003/T%20%E2%8A%86%20G.md), que conecte todos los V del G y que la suma de las aristas seleccionadas sea mínima
    - **Solución:**
    - Si el grafo es conexo, el subgrafo resultante es necesariamente un árbol.
    - Estrategias para resolver el problema:
        - Seleccionar la arista **más corta **en cada iteración
            - Algoritmo de Kruskal.
        - Seleccionar un **vértice al azar **y construir el árbol a partir de él, añadiendo las aristas de menor peso que tenga un extremo en la solución y otro no
            - Algoritmo de Prim.
    - Aplicaciones:
        - Diseño de redes.
            - Mínimo coste.
            - Refuerzo de líneas críticas.
            - Identificación de cuellos de botella.
            - Enrutamiento (evitar ciclos).
        - Soluciones aproximadas a problemas NP.
        - Algoritmos de agrupamiento (clustering).
        - ...
    - Datos relevantes:
        - **Candidatos: c**onjunto de aristas E.
        - **Solución: **se ha construido un árbol con |V| vértices y |V|-1 aristas (extensible a grafos no conexos).
        - **Factibilidad: n**o existe ningún ciclo.
        - **Objetivo: **minimizar la suma de los pesos de las aristas seleccionadas.
        - **Selección: d**epende del algoritmo.
    - ### Algoritmo Kruskal O(|V| |E|):
        - Ordena las aristas de **mayor ** a ** menor **peso.
        - El árbol se construye a partir de ** varias **componentes **conexas**.
        - Sólo se incluye una arista si se une **dos **componentes **conexas**.
        - El algoritmo termina cuando sólo hay **una **componente **conexa**
            - Encuentra la **solución óptima **al problema.
        - Ejemplo de Kruskal:
            - [https://remnote-user-data.s3.amazonaws.com/tedtlFz5ZoLdpjLSWJyRqGp-mJlyPSmwExWjJKeU3b4cPrnv5vIh_hi5ucvjf0r2--JCXdnqZH4RdeIKr8t4jLePZ1qLO7RrPhCvTowqvstlzjNjzbYNq3sv5RVDnyte.png](../../../Uploaded%20Files/Tema3.1_DAA/Highlights/Page%2008/Untitled.md)
        - **Esquema:**
            - [https://remnote-user-data.s3.amazonaws.com/bkSpVh2VnprfQr9DOhIynlmrZy5nRbWZ4fROm1cIVho6ZiqlmIPse2XCY29TQiuc6KMled4UVQ0EtQ9YWr3zu7FduLkI1YRuUc6qpecV9IHsTyGu5rp8JR4_YnJ4cq7h.png](../../../Uploaded%20Files/Tema3.1_DAA/Highlights/Page%2010/Untitled.md)
    - ### Algoritmo de Prim O(|V| |E|):
        - El árbol se construye a partir de una **raíz**.
        - En cada iteración se añade una nueva rama (arista) al árbol.
        - Sólo se incluye una arista si no **genera ciclos**.
        - El algoritmo termina cuando sólo se han añadido **todos **los vértices
            - Encuentra la **solución óptima** al problema.
        - Ejemplo algoritmo Prim:
<iframe class="custom-iframe" src="file:///F:/Vaults%20Obsidian%20BaseDatos%20Apuntes/CARERA%20Y%20PROGRAMACION/Apuntes%20Remnote/2024_2025/Cuatrimestre%202/Dise%C3%B1o%20y%20An%C3%A1lisis%20de%20Algoritmos/PrimAnimation.html" width="700" height="700"></iframe>


        
- ## Caminos mínimos:
    - **Problema:**
    - Dado un grafo conexo G = (V,E), dirigido y ponderado con pesos positivos, se toma uno, v, de los vértices como origen. El problema consiste en determinar la longitud mínima del camino que empieza en v hasta el resto.
    - Estrategias para resolver el problema:
        - Mantener un conjunto de nodos ya explorados para los cuales ya se ha determinado el camino más corto desde v
            - Algoritmo de Dijkstra.
        - Propiedades de los caminos mínimos:
            - Si d(v, u) es la longitud del camino mínimo para ir desde v a u, entonces se satisface:
                - d(v, u) <= d(v, s)+d(s, u)
        - Datos relevantes:
            - **Candidatos:** conjunto de vértices de los que se conoce la distancia mínima desde el origen.
            - **Solución:** cuando no quedan candidatos.
            - **Factibilidad:** siempre es factible.
            - **Objetivo:** minimizar el camino de origen al resto de nodos.
            - **Selección:** candidato con menos distancia al origen.
        - ### Algoritmo de Dijkstra O(|V|^2^)  :
            - Se parte de dos conjuntos de nodos (V = S ∪ C)
                - S: nodos seleccionados para los que se conoce el camino mínimo.
                - C: resto de nodos del grafo.
            - En cada iteración se escoge el nodo de C con menor distancia y se añade a S. Se recalculan los caminos a través del nodo seleccionado.
            - Si no existe arista, se considera distancia infinita
                - Encuentra la **solución óptima** al problema
            - Ejemplo algoritmo Dijkstra:
                - [https://remnote-user-data.s3.amazonaws.com/W44S_vO-mt_yqRZDDWIBkYnj5NAkgOA6x9hd1kNiSDCcgKQUb7nt2eL6NlGphBKXI4cvq0xDUl-6asj5YYBRgeZ2XSnKGwN_ILqxWJgwZ34LNNoBIos4VqTJG7Z4ZF-9.png](../../../Uploaded%20Files/Tema3.1_DAA/Highlights/Page%2020/Untitled.md)
            - **Esquema:**
                - [https://remnote-user-data.s3.amazonaws.com/Nr9ZrLvsGzjlG2PfsiJ5fj5mxXacWnFApQIs49LkhnQne10pX4hAqQ1NQQsMk5RMn5xnhq_Zw2gPZucH0Er3azfnLT18yowql7ved-iPKybfH2BEjiQX_wBI-JXqCsID.png](../../../Uploaded%20Files/Tema3.1_DAA/Highlights/Page%2021/Untitled.md)
- ## Heurísticas voraces:
    - **Problema del coloreado de grafos: **Dado un grafo G = (V, E) no dirigido, asignar un color a cada vértice de tal forma que dos adyacentes no tengan el mismo color.
    - **Objetivo:** Minimizar el número de colores utilizados.
    - **Problema NP: **no existe ningún algoritmo eficiente que garantice un número mínimo de colores para grafos generales
        - Grafos planos: **4 colores** (Teorema de Appel-Hanke)
        - ![](https://remnote-user-data.s3.amazonaws.com/OL9P4-s1cuvrKWIroYL2_OX4tP4I7a1OluDB20_orgHmNXGqHhxLhBTOAMIv_5ZwBzx9emZ2K1QhGXNsY8M7eS2c_rZmiHmMbKfqIlc3D9TPEpYZ6OAP_ETG0HAzBF-M.png)
        - ![](https://remnote-user-data.s3.amazonaws.com/LuU9Fa3XMMHrPgRZgyXqbgVRugAl2iq9G6RuKHWiThNVriOVjEI3VMyyzXFKtlv-2OWxoaARlXU_1p9RoQaGB3Ud6n-Y6VGciF3RUL2ZqBrHwVrKoMPb8CPvbPiN5Mgl.png)
        - 
    - **Problema del viajante: **Dado un grafo G = (V, E), encontrar un camino que empiece y acabe en un vértice v, pasando una única vez por cada vértice de V.
    - **Objetivo:** Obtener el circuito hamiltoniano de coste mínimo.
    - **Problema NP:** no existe ningún algoritmo eficiente que garantice la optimalidad 
        - ![](https://remnote-user-data.s3.amazonaws.com/YGRkIeXcSpE0uz_RWtzvDWMjdFXgQABCBP85LfD1NgKCt6jVnN78lnAemATgELhgDlxg4XWAjAi8-FzzDw63Au8eAI-1Mom6ei_cB7593T8PEinYq2IE-3lNDH9shLWu.png)
        - **Heurística 1: **escoger en cada iteración el vértice más cercano al último nodo añadido al circuito siempre que:
            - No se haya seleccionado previamente
            - No se cierre el circuito
        - **Heurística 2: **escoger las aristas de coste mínimo (como en kruskal) pero garantizando que al final se forme un circuito. 
