- # Definiciones
    - Se suele definir un grafo G=(V,E) como un conjunto de vertices V y de aristas $E \subseteq V \times V$.
    - Usualmente la complejidad de los algoritmos sobre grafos suele medirse en función del número de vértices |V|=n y el número de aristas |E|=m.
    - Existen dos representaciones típicas de grafos:
        - ### Lista de adyacencia:
            - Representación compacta para grafos dispersos (pocas aristas)($|E| \ll|V|^2$).
            - No aseguran un acceso rápido a la hora de comprobar si hay una arista entre 2 vértices dados.
            - **Implementaciones: **
                - Lista de listas: Para grafos no muy densos que den listas cortas.
                - Diccionario de listas: Parecido a lista de listas.
                - Diccionario de Diccionarios: Si es muy denso o no se sabe, conviene.
                    - Espacio, igual O(V+E).
                    - Agregar vértice -> Aunque quieras verificar si se repite O(1)
                    - Agregar arista -> O(1)
                    - Ver si dos vértices son adyacentes -> O(1)
                    - Obtener los adyacentes de un vértice -> O(V) * [Encontrar la lista en diccionario O(1), copiarla O(V)]*  
            - **Costos:** 
                - Espacio: -> O(V+E) * [Generalmente bastante menos espacio]*  
                - Agregar vértice -> O(1)   *[O(V) Si queremos verificar que no está repetido en la lista]*   *[menos O() que en Matriz Ady.]*  
                - Agregar arista -> O(V)
                - Ver si dos vértices son adyacentes -> O(V)
                - Obtener los adyacentes de un vértice -> O(V)
        - ### Matriz de adyacencia: 
            - Aseguran un acceso rápido a la hora de comprobar si hay una arista entre dos vértices dados
            - Se requiere una memoria de $O(V^2)$, y no depende de la densidad del grafo
            - Para grafos densos $|E| \cong |V|^2$
            - **Costos:**
                - Espacio -> O(V^2^)
                - Agregar vértice -> O(V^2^)
                - Agregar arista -> 0(1)  *[Mucho menos O() que Lista Ady.]*  
                - Ver si dos vértices son adyacentes -> O(1)  *[Mucho menos O() que Lista Ady.]*  
                - Obtener los adyacentes de un vértice -> O(V)
                - 
- # Recorrido en profundidad
    - El depth-first search(dfs) profundiza en el grafo siempre que sea posible
    - Dado un vértice antes de visitar su hermano, visita su hijo (Equivalente a un recorrido preorden).
    - Suele implementarse de forma recursiva
    - Se incluye el conjunto verticesVisitados para evitar ciclos en la búsqueda.
    - ### Pseudocódigo:
        - 
            - 
                - DFS Recursividad (rp llama a rp):
                - ![](https://remnote-user-data.s3.amazonaws.com/pLaez664cP4P-QaWTYKOOqu2wEtoazA3CHxxK0CP_osIS7DbHWFZCeFMrDgR3kyfObSSV89UrkUYpHTNgfzwQezAK5RG-RkJHp7uF18OBxui7mvPRONV26n43P-f2VqE.png)
                - ![](https://remnote-user-data.s3.amazonaws.com/rOSw7VYZCImAwo7iyUsgFHCJrbubD4WabUzgBmvr3M5sn8EMSakqdCbOuSFQSnYt5U89NVP12TgsfLQx2dT3q4ehAGgn7tBg0Jh7W3Kc_DSGo7cZIK2WtJ4s8hMrnlBO.png)
            - 
                - DFS 
                - Iterativo (con pila)  *[DPila]*  
                - ![](https://remnote-user-data.s3.amazonaws.com/JOGgmNKPSJ-CxO44H4r8ZB84V7aqdBO6rb2xNVpv5cfqOCW-6XVAViOBiniBkP7aPMWTSUY4dBIaONujiD3QOrtBNS4-LrPC8VS9krV3yWoTUK2o9-Am7U3aTZlb1FE5.png)
                - 
    - .
        ```
        def dfs_standard(graph, start_node):
    visited = set()
    result = []
    
    def dfs_recursive(node):
        # Marcar como visitado
        visited.add(node)
        # Procesar el nodo ahora
        result.append(node)
        
        # Explorar vecinos
        if node in graph:
            for neighbor in graph[node]:
                if neighbor not in visited:
                    dfs_recursive(neighbor)
        
        # No hay procesamiento aquí
    
    dfs_recursive(start_node)
    return result
        ```
    - Complejidad global del algoritmo es: $O(max(V,E))$. Cada vértice se visita una vez O(V) y el algoritmo examina todas las aristas O(E).
    - El DFS de un grafo conexo G crea un árbol de recubrimiento T:
        - Las aristas de T son un subconjunto de las de G.
        - La raíz de T es el punto de partida de la exploración de G.
    - ![](https://remnote-user-data.s3.amazonaws.com/qSPTv7m_moqheQjXA9ufrRnH3W4SiLw-UH5IVdojWEdPEW1IZht2I0Yn8i7dy1FziDZGpEjMGrpNNTvA_JLpmvWM_Ib8ty240w-9OPklmYPFnjkRrdlH2LcA8MPjAge0.png)->![](https://remnote-user-data.s3.amazonaws.com/eHe2KA7T304d2eaJwcXnPOoQHegM3zRz4GJkzHfAw5s6Y-Y_gbqgLEbJkNRO8_O_0Zi1UClFPcfGd2RjJElT7nujqAqkzLSvzteoRZVP63c5xGve9pL296DZbfiN4qSN.png) 
    - Si el grafo no es conexo se obtiene un grafo por cada componente conexa (bosque).
        -  *Ejemplo de con grafo dirigido(distingue entre adyacentes e incidentes) no conexo:*  
            - ![](https://remnote-user-data.s3.amazonaws.com/jvNfPVLGxf6F1aTohm_gpoz384XaNkc_8ljVCZ-ut-7ehc-BJWNlxrpKN1CwizwHuW5fPJOwwRr5ol8QVTinsS_2Um-Qy2ncUAMoUEP47ltHwcNi5uZAkuBDOsgoZ0O8.png)->![](https://remnote-user-data.s3.amazonaws.com/MibyeH5bCReWpo1n-Vkkhd1Ojq9w6_xy4UfjQUU0MvE5DhMVQ0BlOusutTQKqeRuYZXrVhgPDsaxDjqP5rmNQkJk__T-7HKZ10QvT5rQVI_L68DT8VO4-dunOHMDQnKs.png)
    - Se emplea en utilidades concretas (debido a la información sobre la estructura que aporta el DFS) en algoritmos más avanzados *^Algunos al final del tema^(Puntos de articulación...).
    - Para muchos algoritmos es indiferente BFS y DFS.

- # Recorrido en Anchura
    - El breath-first search(dfs) recorre la frontera en anchura.
    - Visita todos los vértices a una distancia k antes de descubrir el primer vértice a la distancia k+1.
    - Suele implementarse de forma iterativa.
    - Se tiene que incluir una cola con los vértices visitados para evitar ciclos y establecer el orden de la búsqueda.
    - Dado un grafo G=(V,E) y un vértice inicial S:
        - Calcula la distancia (menor número de vértices) desde S, hasta los vértices alcanzables.
        - Produce un árbol de recorrido en anchura donde la raíz es S.
        - Para cualquier V alcanzable desde S, la ruta en el árbol de recorrido de anchura de S a V es el camino más corto entre esos dos vértices.
        - Adecuado para dirigidos y no dirigidos. 
        - ### Pseudocódigo:
            - BFS Iterativo (ra no llama a ra): (COLA no pila como DFS) 
            - ![](https://remnote-user-data.s3.amazonaws.com/NRSfUddLc5Qo90FwcZ3I3lB8P4yQqzNEYs3K7CDxu9utJS_jqIhJuvUnbcS9iHmzimGPQ4pzFL3aKeyxQY9qOPpRpLI8iWDnYcqbZEqO0qDKgeTfGqNLXEDjnKZCmdmP.png)
            - ![](https://remnote-user-data.s3.amazonaws.com/i_hr7_Mc5Nlw729VipmifA4L8XwlrCHkEUOza9j6rAf6eD1yauDvLXPQ-1n6V_mSEDl9d9de1tfjzc8Mtm9GeZUVIcbjBktcuMyc2vYjsw4-Y2TLwCOwb8CMowXrZdVr.png)
        - 
            - 
            - 
    - Complejidad = BFS -> $O(max(V,E))$
    - También genera árboles de recubrimiento. Si el grafo es conexo, solo uno.
    - Se emplea en exploraciones parciales de grafos, para hallar el camino más corto entre dos puntos de un grafo, etc...
    - Ejemplo recorrido en anchura:
        - ![](https://remnote-user-data.s3.amazonaws.com/mg1sU6bka5H6wEtOD3ftWrimlTWt2KM5IJLecVgAskWtkWdIaYVmrPNUDCA0Qncc0X_90zZDmcgeMAn5AKy6smDg2mGZrNudj_AYNdbP2mGSo02NSR5kHeeKCGMoazkY.png)
        - ![](https://remnote-user-data.s3.amazonaws.com/nOJc55iVSMrDLqwEkm6QDAOt-XVr0pIg0Q1jW3-fqgfz8U7JsYRAAu9W0mIUrUQW0NgIxoA72Cw0vBKkWwntDs_hp5gvkq7zxUUWGEUgxcn-qMeS2D2GFFMOzbPxiQGA.png)

- # Algoritmos sobre grafos y Ordenación Topológica
    - ## Ordenación Topológica (Una de las aplicaciones de BFS/DFS):
        - Ordenamiento no comparativo, no se tiene orden total (a<b<c) se tiene un orden parcial (a<b, c<b, no tenemos relación entre a y c (a,c,b / c,a,b) -> Los dos serían ordenes válidos (Orden de vestirse)). 
            - Aplicaciones teóricas:
                - Tareas a realizar (algunas antes que otras).
                - Makefile: algunas cosas se compilan antes que otras.
                - Plan de estudios: Hay materias que deben hacerse antes que otras.
                - ...
        - Opciones:
            - Similar a recorrido BFS (basado en los grados de entrada de cada uno de los vértices(cuantas aristas le llegan)).
            - ![](https://remnote-user-data.s3.amazonaws.com/dCJgL6w_l1OUJoUwGQzZUSRC4t5TCGxo_c7Ihl6FO8pMtcZixe3H_mN7U25IDg36kt4RiF8T3df4ZN1C0xxPnAby26oojm9S0Ar61uVz2MeZWR43oynsOcbq9vEU7mUa.png)
            - Usando un recorrido DFS con muy poca modificación. (va recorriendo hasta que llega a un final, por ejemplo taller 1 en el grafo de arriba y lo mete en una pila, asegurando que salga el último * [puede empezar desde cualquier nodo]* ) *. * Si prefieres profundizar antes de meterte en otras cosas usa este (ej: Ver el universo Marvel acabando primero las de Spiderman que no tengan la condición de verse después que otra). 
                - .
                    ```
                    #topsort recursive DFS
def topological_sort(graph):
    visited = set()
    result = []
    
    def dfs_topo(node):
        # Marcar como visitado
        visited.add(node)
        # No hay procesamiento aquí
        
        # Explorar vecinos
        if node in graph:
            for neighbor in graph[node]:
                if neighbor not in visited:
                    dfs_topo(neighbor)
        
        # Procesar el nodo en backtracking
        result.append(node)
    
    # Iniciar desde cada nodo no visitado
    for node in graph:
        if node not in visited:
            dfs_topo(node)
    
    # Invertir el resultado para obtener la ordenación
    return result[::-1]
                    ```
        - Dado un grafo dirigido y acíclico, se denomina ordenación topológica a una disposición lineal de los nodos tal que, dado un arco (u,v), el nodo u esté antes que v en la ordenación.
            - Un vértice se visita sí y solo sí se han visitado todos sus predecesores.
            - En caso de grafos con ciclos, el algoritmo sigue siendo válido, pero la interpretación no es directa.
        - Aplicaciones prácticas:
            - Fases de un proyecto (PERT).
            - Evaluación de atributos en la fase semántica de un compilador.
        - Ejemplo con recorrido en profundidad. Distancia y finalización.
            - ![](https://remnote-user-data.s3.amazonaws.com/NBGIzEmGVLYLqgX2yA9jyVY3Pe1BC6byJfY56dPpnNxkLTJ4lnuOUNLp3ppYx54jEZZttQ12pnWjnZRQrUGnoVUoR6VcwCSc4-0_E_FN9ewnnRxl1Yw9di76FTyJC7Uq.png) ![](https://remnote-user-data.s3.amazonaws.com/KNbAwlh3VD-ktTp0729unsjprP2vEaw9Eow9DG3E6SpXs1KKh5cmUZlLS_59eeQiUfhJwbPvFihQr8o_uPXf6jY3qlc-P-8hKbvYnzI-BwmzoKB7Knn-gaZgDmxmXvto.png)
            - ![](https://remnote-user-data.s3.amazonaws.com/MjlVSXJhT3E0cg73_1VGoRltjJXR9pi5_Is2QMc1ksQhoikAkK6GjmpL9tux_FjhM0o73siwLKhMMV86oPMCS2t2S89yHBJ824IrjfjfPxHHhn4YDt2BuzK5Zo_ireBr.png)
    - ## Algoritmos sobre grafos  *(Términos, procedimientos,...)* :
        - Un **grafo conexo** es un grafo no dirigido donde existe un camino entre cualquier par de nodos. Un **grafo fuertemente conexo** es un grafo dirigido donde existe un camino entre cualquier par de nodos, considerando la dirección de las aristas  s.
        - 
        - 
        - ara descomponer un grafo G en sus componentes fuertemente conexas:
            - Aplicar la ordenación topológica sobre G.
            - Calcular el grafo traspuesto G^T^  *(Invertir el sentido de los arcos)* .
            - Aplicar DFS sobre G^T^ iniciando la búsqueda en los nodos de mayor a menor tiempo de finalización obtenidos en la primera ejecución de búsqueda en profundidad.
            - El resultado será un bosque de árboles. Cada árbol es una componente fuertemente conexa.
        - **Puntos de articulación: **Un vértice V de un grafo conexo es un punto de articulación si el subgrafo que se obtiene al eliminarlo (Junto con sus aristas) no es conexo.
        - **Grafo biconexo****(o no articulado)**: aquél grafo que no tiene puntos de articulación.
        - **Grafo bicoherente (o 2-arista conexo): **aquél grafo cuyos puntos de articulación están unidos a cada componente del subgrafo restante por, al menos, dos aristas. 
        - Si el grafo representa una red de comunicaciones:
            - Si es **biconexo ** nos asegura el correcto funcionamiento de la red, aunque falle uno de los equipos.
            - Si es **bicoherente **nos asegura el correcto funcionamiento de la red, aunque falle una de las líneas de transmisión. 
        - ### Cálculo de los puntos de articulación g dirigido(Variacion del tarjan  *(tb:Algoritmo puntos articulación g no dirigidos y componentes fuertemente conexas)* DFS):
            - ![](https://remnote-user-data.s3.amazonaws.com/2EuDoKYtFyo3gr5WEfqjam82HpY4-V5tK8VQIM4OkR01vOsShys5CucRH1hZO88rUuZq-YNZwHgGmR_a4ggbGHxP7IzkyVxUZhw6b2gvlwY3-b9bf4OUdXRKj_XSb4RB.png)
            - Sea V cualquier vértice del árbol (excepto la raíz) y X un hijo de V:
                - Si masAlto[X] < preOrden[V] implica que se puede llegar desde x a regiones más altas sin pasar por (V,U). Entonces U no es un punto de articulación. (con mis palabras: Si alguno de sus hijos, a través de sus hijos puede llegar a un nodo más alto, sin pasar por la arista del padre(él) al primer hijo, no es punto de articulación(los puentes con líneas intermitentes valen como camino de subida))
                - Si preOrden[X] ≥ masAlto[V] no se puede llegar desde U a regiones más altas del grafo sin pasar por (V,U). Entonces U es un punto de articulación.
            - Si U es la raíz del árbol y tiene más de un hijo, es un punto de articulación, si no, no.
            - *****En el ejemplo anterior los puntos de articulación son 1 y 4, el 1 en el árbol del recorrido es la raíz del árbol y tiene 2 hijos, por lo que es **punto de articulación**, además, alguno(en este caso ninguno) de los hijos de 4 (7 en este caso), puede llegar a un nivel más alto que 4, por lo que 4 es **punto de articulación**. 
            - Ejemplo de pseudo-código con DFS:
                - ![](https://remnote-user-data.s3.amazonaws.com/mAEhhnKkI0VMwxIdyR9YqVoBjzQAkALknieIA3hZ4S8jR8o4jvN_uBrHDdkMs132szun5SdKgBWmdyXA3oUSsvHvnViGlCrZMorkhISi_Dkodzbx8kCAjVu3_rZ_hMK9.png)
        - Otras aplicaciones interesantes:
            - Comprobar que un grafo es bipartito.
            - Detectar ciclos en grafos.
            - Camino más largo en un DAG.
            - Determinar si dos nodos están conectados o no.
            - Caminos y ciclos eulerianos
            - Cierre transitivo.
            - Caminos entre un origen y un destino con K aristas.

